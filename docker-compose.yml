version: '3.8'

# NOTE:
# You mentioned you won't use Docker until deployment. This file is now
# oriented toward production use while remaining idle in local-only dev.
# Local dev: run native Postgres or in-memory (USE_DB=false) and ignore this file.
# Prod deploy: `docker compose --env-file .env.production up -d` (create that env file first).

services:
  postgres:
    image: postgres:16-alpine
    container_name: enyalis-postgres
    profiles: [prod]
    environment:
      POSTGRES_USER: ${DB_USER:-enyalis}
      POSTGRES_PASSWORD: ${DB_PASSWORD:-change_me}
      POSTGRES_DB: ${DB_NAME:-enyalis_db}
    volumes:
      - pgdata:/var/lib/postgresql/data
      # Optional: place *.sql files in ./db/init to auto-run on first launch
      # - ./db/init:/docker-entrypoint-initdb.d:ro
    # EXPOSE DB ONLY IF YOU REALLY NEED HOST ACCESS. Comment out for extra safety.
    # ports:
    #   - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"]
      interval: 5s
      timeout: 3s
      retries: 12
    restart: unless-stopped
    networks:
      - appnet

  app:
    build: .
    container_name: enyalis-app
    profiles: [prod]
    depends_on:
      postgres:
        condition: service_healthy
    ports:
      - "3000:3000"
    env_file:
      - .env.production
    environment:
      # Override / ensure critical runtime vars (env file takes precedence)
      NODE_ENV: production
      DB_HOST: postgres
      DB_PORT: 5432
      USE_DB: ${USE_DB:-true}
      REQUIRE_DB: ${REQUIRE_DB:-true}
      # JWT_SECRET should be defined in .env.production (never default in prod)
    restart: unless-stopped
    networks:
      - appnet
    # Example of running migrations first (uncomment once you add a migration script)
    # command: sh -c "npm run migrate && node src/server.js"

volumes:
  pgdata:

networks:
  appnet:
    driver: bridge
