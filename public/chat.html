<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enyalis - Discord-like Chat</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/x-icon" href="favicon.ico">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        /* Enyalis Brand Tokens */
        :root {
            /* Base surfaces and text (kept aligned with existing app palette) */
            --bg-primary: #2f3136;
            --bg-secondary: #36393f;
            --bg-hover: #34373c;
            --text-primary: #ffffff;
            --text-secondary: #b9bbbe;
            --border-color: #4f545c;

            /* Brand gradient derived from logo (red → crimson → magenta) */
            --brand-1: #ff3b1f;   /* fiery red/orange */
            --brand-2: #ff2241;   /* crimson */
            --brand-3: #ff2975;   /* magenta/pink */
            --brand-gradient: linear-gradient(135deg, var(--brand-1), var(--brand-2) 50%, var(--brand-3));
            --brand-glow: rgba(255, 41, 117, 0.35);
            --brand-glow-strong: rgba(255, 41, 117, 0.55);
        }
        /* Discord-like Layout */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        .discord-container {
            display: flex;
            height: 100vh;
            background: #36393f;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }

        /* Ensure consistent centering for all circular avatar/button elements */
        .server-icon, .message-avatar, .dm-avatar, .user-avatar, .member-avatar, 
        .quick-add-btn, .user-result-avatar, .friend-card-avatar {
            text-align: center;
            vertical-align: middle;
        }

        /* Server List (Left Panel) */
        .server-list {
            width: 70px;
            background: #202225;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 12px 0;
            gap: 8px; /* Keep compact spacing for top logo, separator, add button */
            overflow-y: auto;
        }

        /* Space user servers individually (not just between containers) */
        #user-servers {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px; /* Visual space between each server bubble */
        }

        .server-icon {
            width: 48px;
            height: 48px;
            background: var(--brand-2); /* default for letter-only icons (red) */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
            font-size: 18px;
            line-height: 1;
            position: relative;
            overflow: hidden;
        }

        /* Hover color only for letter-only icons */
        .server-icon:not(.has-image):hover {
            border-radius: 16px;
            background: var(--brand-1);
        }

        /* Image-backed server icons */
        .server-icon.has-image {
            background-color: transparent; /* remove blue base */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            transition: filter 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease, background-size 0.25s ease, border-radius 0.2s ease;
        }

    /* Prevent hover blue color from affecting image */
    .server-icon.has-image:hover { background-color: transparent; }

        /* Subtle dim for unselected image icons */
        .server-icon.has-image:not(.active) {
            filter: grayscale(25%) saturate(0.9) brightness(0.95);
        }

        /* Active state (common) */
        .server-icon.active {
            border-radius: 16px;
            box-shadow: 0 0 10px var(--brand-glow);
        }

        /* Keep gradient only for letter-only icons */
        .server-icon:not(.has-image).active {
            background: var(--brand-gradient);
        }

        /* For image icons, animate the image itself */
        .server-icon.has-image.active {
            /* keep the background-image; only tweak visual treatment */
            filter: none;
            background-size: 110%; /* gentle zoom to indicate selection */
            box-shadow: 0 0 0 2px rgba(255,255,255,0.08), 0 0 16px var(--brand-glow);
        }

        /* Hover animation for image icons (unselected) */
        .server-icon.has-image:not(.active):hover {
            background-size: 105%;
            filter: grayscale(10%) saturate(1.05) brightness(1.06);
            box-shadow: 0 0 0 2px rgba(255,255,255,0.05), 0 6px 14px rgba(0,0,0,0.25);
        }

        .server-icon.home {
            background: var(--brand-gradient);
            padding: 0;
        }

        .server-icon.home img {
            width: 100%;
            height: 100%;
            border-radius: inherit;
        }

        .server-separator {
            width: 32px;
            height: 2px;
            background: linear-gradient(90deg, var(--brand-1), var(--brand-3));
            border-radius: 1px;
            margin: 4px 0;
            opacity: 0.7;
        }

        .add-server {
            background: #36393f;
            color: #43b581;
            position: relative;
            font-size: 0; /* Hide the text + */
        }
        
        .add-server::before,
        .add-server::after {
            content: '';
            position: absolute;
            background: #43b581;
            border-radius: 1px;
            transform-origin: center;
            will-change: transform;
        }
        
        /* Horizontal bar */
        .add-server::before {
            width: 16px;
            height: 2px;
            top: 23px;
            left: 16px;
        }
        
        /* Vertical bar */
        .add-server::after {
            width: 2px;
            height: 16px;
            top: 16px;
            left: 23px;
        }

        .add-server:hover {
            background: #43b581;
            color: white;
        }
        
        .add-server:hover::before,
        .add-server:hover::after {
            background: white;
        }

        /* Channel Panel (Middle Panel) */
        .channel-panel {
            width: 240px;
            background: #2f3136;
            display: flex;
            flex-direction: column;
        }

        .server-header {
            height: 48px;
            padding: 0 16px;
            display: flex;
            align-items: center;
            border-bottom: 1px solid #202225;
            font-weight: bold;
            cursor: pointer;
        }

        .server-header:hover {
            background: #34373c;
        }

        .channels-container {
            flex: 1;
            overflow-y: auto;
            padding: 16px 8px;
        }

        .channel-category {
            color: #8e9297;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin: 16px 8px 0;
            letter-spacing: 0.02em;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .channel-manage-btn {
            background: none;
            border: none;
            color: #8e9297;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: all 0.2s ease;
        }

        .channel-category:hover .channel-manage-btn {
            opacity: 1;
        }

        .channel-manage-btn:hover {
            background: #40444b;
            color: #dcddde;
        }

        .channel-list {
            list-style: none;
            padding: 0;
            margin: 8px 0;
        }

        .channel-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            margin: 1px 0;
            border-radius: 4px;
            cursor: pointer;
            color: #8e9297;
            font-size: 14px;
        }

        .channel-item:hover {
            background: #34373c;
            color: #dcddde;
        }

        .channel-item.active {
            background: linear-gradient(90deg, rgba(255, 41, 117, 0.18), rgba(255, 59, 31, 0.18));
            border-left: 3px solid var(--brand-3);
            color: #ffffff;
        }

        .dm-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin: 2px 0;
            border-radius: 4px;
            cursor: pointer;
            color: #8e9297;
            font-size: 14px;
            transition: background-color 0.15s ease;
        }

        .dm-item:hover {
            background: #34373c;
            color: #dcddde;
        }

        .dm-item.active {
            background: linear-gradient(90deg, rgba(255, 41, 117, 0.18), rgba(255, 59, 31, 0.18));
            border-left: 3px solid var(--brand-3);
            color: #ffffff;
        }

        .dm-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            margin-right: 12px;
            /* JS will set per-user gradient; keep a subtle fallback */
            background: linear-gradient(45deg, #555, #444);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            flex-shrink: 0;
            line-height: 1;
        }

        .dm-username {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
            .member-name {
                font-weight: 500;
                font-size: 14px;
                color: #dcddde; /* neutral default; JS sets role color */
            }
        .dm-last-message {
            font-size: 12px;
            color: #72767d;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }

        /* Clickable links in chat messages */
        .message-text .chat-link {
            color: var(--brand-3);
            text-decoration: none;
            word-break: break-word;
        }
        .message-text .chat-link:hover {
            text-decoration: underline;
            color: #ff5a8f;
        }
        .message-text .chat-link:focus-visible {
            outline: 2px solid var(--brand-3);
            outline-offset: 2px;
            border-radius: 2px;
        }

        .no-dms {
            text-align: center;
            color: #72767d;
            font-size: 14px;
            padding: 20px;
        }

        .channel-icon {
            width: 20px;
            margin-right: 6px;
            font-size: 16px;
        }

        /* Slightly larger icon for Friends entry */
        .channel-icon.friends { width: 24px; }

        .badge {
            background: var(--brand-gradient);
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 11px;
            margin-left: auto;
            font-weight: bold;
        }

        .user-area {
            height: 52px;
            background: #292b2f;
            display: flex;
            align-items: center;
            padding: 0 8px;
        }

        .user-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--brand-gradient);
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            line-height: 1;
        }

        .user-details {
            display: flex;
            flex-direction: column;
        }

        .username {
            font-size: 14px;
            font-weight: bold;
            color: white;
        }

        .user-status {
            font-size: 12px;
            color: #8e9297;
        }

        /* Chat Area (Main Panel) */
        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            z-index: 1;
            min-height: 0;
            height: 100%;
            overflow: hidden;
            transition: margin-right 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .chat-area.no-transition {
            transition: none !important;
        }

        .chat-area.expanded {
            margin-right: -240px; /* Expand into members panel space */
        }

        .members-panel {
            width: 240px;
            background: #2f3136;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #202225;
            transform: translateX(0);
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            z-index: 2;
            overflow: hidden;
            flex-shrink: 0;
        }

        .members-panel.collapsed {
            transform: translateX(100%); /* Slide completely out */
        }

        .members-header {
            height: 48px;
            padding: 0 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #202225;
            color: #8e9297;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .members-count {
            color: #8e9297;
        }

        .members-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        /* Members panel list item styles + hover */
        #members-list .member-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 6px 12px;
            margin: 2px 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 120ms ease, transform 90ms ease, box-shadow 120ms ease;
        }
        #members-list .member-item:hover {
            background: #34373c;
        }
        #members-list .member-item:hover .member-avatar {
            box-shadow: 0 0 0 2px rgba(255,255,255,0.04), 0 4px 12px rgba(0,0,0,0.35);
        }
        #members-list .member-item:active {
            transform: translateY(1px);
        }
        #members-list .member-item:focus-visible {
            outline: 2px solid var(--brand-3);
            outline-offset: 2px;
        }

        /* Inline admins chips to reduce vertical space */
        .admins-inline {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            padding: 4px 16px 8px 16px;
        }

        .admin-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #2b2d31;
            border: 1px solid #202225;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s ease, transform 0.15s ease;
        }

        .admin-chip:hover { background: #34373c; transform: translateY(-1px); }

        .admin-avatar {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #5865f2;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            line-height: 1;
        }

        .admin-name { color: #dcddde; }

        /* Ensure full member names show (wrap, no ellipsis) */
        .members-list .member-name {
            white-space: normal;
            overflow: visible;
            text-overflow: clip;
            word-break: break-word;
        }

        /* Server Settings Member Items */
        #server-members-list .member-item {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            margin-bottom: 2px;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
        }

        #server-members-list .member-item:hover {
            background-color: rgba(79, 84, 92, 0.3);
            transform: translateX(2px);
        }

        #server-members-list .member-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            color: white;
            margin-right: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        #server-members-list .member-details {
            flex: 1;
        }

        #server-members-list .member-username {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 2px;
        }

        #server-members-list .member-role {
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        #server-members-list .member-actions select {
            background: #40444b;
            color: #dcddde;
            border: 1px solid #4f545c;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #server-members-list .member-actions select:hover {
            border-color: #7289da;
            background: #36393f;
        }

        #server-members-list .member-actions select:focus {
            outline: none;
            border-color: #7289da;
            box-shadow: 0 0 0 2px rgba(114, 137, 218, 0.2);
        }

        .member-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #5865f2;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            margin-right: 12px;
            line-height: 1;
        }

        .member-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .member-name {
            font-weight: 500;
            font-size: 14px;
        }

        .member-role {
            font-size: 12px;
            color: #8e9297;
        }

        .chat-header {
            height: 48px;
            background: #36393f;
            border-bottom: 1px solid #202225;
            display: flex;
            align-items: center;
            padding: 0 16px;
            flex-shrink: 0;
        }

        .members-toggle-btn {
            background: #36393f;
            border: 1px solid #202225;
            color: #8e9297;
            font-size: 14px;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px 0 0 4px;
            position: fixed;
            right: 240px; /* Start at panel edge */
            top: 50%;
            transform: translateY(-50%);
            transition: all 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            z-index: 10;
            width: 30px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .members-toggle-btn:hover {
            background: #40444b;
            color: #dcddde;
        }

        .members-toggle-btn.collapsed {
            right: 0; /* Move to right edge when panel is hidden */
            border-radius: 4px 0 0 4px;
            background: var(--brand-gradient);
            color: white;
            box-shadow: 0 0 10px var(--brand-glow);
        }

        .members-toggle-btn.collapsed:hover {
            box-shadow: 0 0 14px var(--brand-glow-strong);
        }

        /* Arrow rotation animation */
        .members-toggle-btn .arrow {
            transition: transform 0.35s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            font-size: 16px;
        }

        .members-toggle-btn.collapsed .arrow {
            transform: rotate(180deg);
        }

        .channel-name {
            font-size: 16px;
            font-weight: bold;
            margin-left: 8px;
        }

        .channel-info {
            color: #8e9297;
            margin-left: 12px;
            font-size: 14px;
        }

        .messages-area {
            position: absolute;
            top: 48px; /* Below chat header */
            bottom: 0;
            left: 0;
            right: 0;
            overflow-y: auto;
            padding: 16px;
            padding-bottom: 120px; /* Add space for message input */
            background: #36393f;
        }

        .message {
            display: flex;
            margin-bottom: 16px;
            padding: 2px 0;
        }

        .message:hover {
            background: rgba(4, 4, 5, 0.07);
            margin: 0 -16px 16px;
            padding: 2px 16px;
        }

        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--brand-gradient);
            margin-right: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
            font-size: 16px;
            color: white;
            line-height: 1;
        }

        .message-content {
            flex: 1;
        }

        .message-header {
            display: flex;
            align-items: baseline;
            margin-bottom: 4px;
        }

        .message-author {
            font-weight: bold;
            color: #dcddde; /* neutral default; JS sets role color */
            margin-right: 8px;
        }

        .message-timestamp {
            font-size: 12px;
            color: #8e9297;
        }

        .message-text {
            color: #dcddde;
            line-height: 1.375;
            word-wrap: break-word;
        }

        .message-attachment {
            margin-top: 8px;
        }

        .message-image {
            max-width: 400px;
            max-height: 300px;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .message-image:hover {
            transform: scale(1.02);
        }

        /* Animated 3-dots message menu */
        .message-menu { 
            transform: scale(.95) translateY(-4px); 
            opacity: 0; 
            transform-origin: top right; 
            transition: transform 140ms cubic-bezier(.4,.14,.3,1), opacity 140ms ease; 
            will-change: transform, opacity; 
            backdrop-filter: blur(4px); 
        }
        .message-menu.open { 
            transform: scale(1) translateY(0); 
            opacity: 1; 
        }
        .message-menu .menu-item { 
            opacity: 0; 
            transform: translateX(6px); 
            animation: fadeSlideIn .25s ease forwards; 
            background: transparent; 
            position: relative; 
        }
        .message-menu.open .menu-item:nth-child(1){ animation-delay: 40ms; }
        .message-menu.open .menu-item:nth-child(2){ animation-delay: 80ms; }
        .message-menu .menu-item:hover { background: #393c43; }
        .message-menu .menu-item.menu-delete:hover { background:#3a2325; }
        .message-menu .menu-item.confirming { color:#ffbf47 !important; font-weight:600; }
        .message-menu .menu-item.confirming:hover { background:#4a4029; }
        @keyframes fadeSlideIn { from { opacity:0; transform: translateX(6px);} to { opacity:1; transform: translateX(0);} }
        .message-edited-indicator { color:#8e9297; font-size:11px; font-weight:400; }
        .message-content.deleted .message-edited-indicator { display:none; }

        /* Image modal */
        .image-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            cursor: pointer;
        }

        .image-modal img {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
        }

        /* Message Input */
        .message-input-area {
            padding: 0 16px 24px;
            background: #36393f;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 10;
            /* Remove separator line to avoid side lines extending past the rounded input */
            border-top: none;
        }

        .message-input-container {
            background: #40444b;
            border-radius: 8px;
            padding: 12px;
            display: flex;
            align-items: center;
            width: 100%;
            cursor: text; /* indicate click-to-type anywhere */
        }

        .message-input {
            flex: 1;
            background: none;
            border: none;
            color: white;
            font-size: 14px;
            outline: none;
        }

        .message-input::placeholder {
            color: #8e9297;
        }

        .message-actions {
            display: flex;
            gap: 8px;
            margin-left: 12px;
        }

        .action-btn {
            background: none;
            border: none;
            color: #b9bbbe;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            font-size: 18px;
        }

        .action-btn:hover {
            color: #dcddde;
            background: #4f545c;
        }

        /* SVG icon helpers */
        .icon-20 { width: 20px; height: 20px; display: block; }
        .icon-24 { width: 24px; height: 24px; display: block; }
        .action-btn img { transition: transform 0.15s ease; }
        .action-btn:hover img { transform: scale(1.05); }

        /* Modals */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
        }

        .modal-content {
            background: #36393f;
            margin: 15% auto;
            padding: 20px;
            border-radius: 8px;
            width: 440px;
            color: white;
        }
        /* Override layout for the larger Account Settings modal so it isn't pushed too low */
        #account-settings-modal .modal-content {
            margin: 4vh auto 0 auto; /* Move it up compared to default 15% */
            height: 76vh; /* Slightly smaller so no crop */
            max-height: 86vh; /* Safety on very tall screens */
        }

        .modal-header {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 16px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            color: #8e9297;
        }

        .form-input {
            width: 100%;
            padding: 10px;
            background: #202225;
            border: 1px solid #202225;
            border-radius: 4px;
            color: white;
            font-size: 16px;
        }

        .form-input:focus {
            border-color: #5865f2;
            outline: none;
        }

        .form-help {
            font-size: 12px;
            color: #8e9297;
            margin-top: 4px;
            line-height: 1.4;
        }

        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 24px;
        }

        .btn {
            padding: 10px 24px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .btn-primary {
            background: var(--brand-gradient);
            color: white;
            border: none;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, var(--brand-1), var(--brand-3));
            transform: translateY(-1px);
            box-shadow: 0 2px 8px var(--brand-glow);
        }

        .btn-secondary {
            background: transparent;
            color: white;
        }
        /* Server Preview Modal Styles */
        .server-preview-content {
            display: flex;
            gap: 16px;
            align-items: center;
        }
        .server-icon-large {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #5865f2;
            font-weight: bold;
            font-size: 24px;
        }
        .server-preview-info h3 {
            margin-bottom: 8px;
        }
        .server-preview-info p {
            color: #b9bbbe;
            margin-bottom: 8px;
        }
        .server-preview-stats {
            color: #8e9297;
            font-size: 13px;
        }

        .btn-secondary:hover {
            background: #4f545c;
        }

        /* Server Modal Tabs */
        .server-modal-tabs {
            display: flex;
            margin-bottom: 24px;
            border-bottom: 2px solid #40444b;
        }

        .server-tab-btn {
            background: transparent;
            border: none;
            color: #8e9297;
            padding: 12px 24px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            line-height: 1;
        }

        .server-tab-btn:hover {
            color: #dcddde;
        }

        .server-tab-btn.active {
            color: var(--brand-3);
        }

        .server-tab-btn.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--brand-gradient);
            border-radius: 1px;
        }

        .server-tab-content {
            display: none;
        }

        .server-tab-content.active {
            display: block;
        }

        /* File upload styling */
        .file-input {
            display: none;
        }

        /* Image preview area */
        .image-preview-area {
            display: none;
            padding: 8px 16px;
            background: #40444b;
            border-top: 1px solid #202225;
            position: absolute;
            bottom: 80px;
            left: 0;
            right: 0;
            z-index: 11;
        }

        .image-preview-container {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            max-height: 120px;
            overflow-y: auto;
        }

        .image-preview {
            position: relative;
            display: inline-block;
        }

        .image-preview img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            border: 2px solid #202225;
        }

        .image-preview .remove-image {
            position: absolute;
            top: -4px;
            right: -4px;
            width: 20px;
            height: 20px;
            background: #f04747;
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            line-height: 1;
        }

        /* Welcome message */
        .welcome-message {
            text-align: center;
            color: #8e9297;
            margin-top: 50px;
        }

        .welcome-message.dm-welcome {
            background: linear-gradient(135deg, rgba(255, 41, 117, 0.10), rgba(255, 59, 31, 0.10));
            border: 1px solid rgba(255, 41, 117, 0.25);
            border-radius: 8px;
            padding: 20px;
            margin: 20px auto;
            max-width: 500px;
        }

        .welcome-message.dm-welcome h3 {
            color: var(--brand-3);
            margin-bottom: 10px;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 16px;
        }

        ::-webkit-scrollbar-track {
            background: #2e3136;
        }

        ::-webkit-scrollbar-thumb {
            background: #202225;
            border: 4px solid #2e3136;
            border-radius: 8px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #1a1d23;
        }

        /* Search and profile views */
        .search-container {
            padding: 20px;
        }

        .search-bar {
            width: 100%;
            padding: 12px 16px;
            background: #40444b;
            border: 1px solid #202225;
            border-radius: 4px;
            color: white;
            font-size: 16px;
            margin-bottom: 20px;
        }

        .search-bar:focus {
            border-color: var(--brand-3);
            outline: none;
        }

        .user-result {
            display: flex;
            align-items: center;
            padding: 12px;
            background: #2f3136;
            border-radius: 8px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .user-result:hover {
            background: #34373c;
        }

        .user-result .message-avatar {
            margin-right: 12px;
        }

        .user-info-text {
            flex: 1;
        }

        .user-result .username {
            font-weight: bold;
            color: white;
            font-size: 16px;
        }

        .user-result .user-email {
            color: #8e9297;
            font-size: 14px;
        }

        .add-friend-btn {
            background: var(--brand-gradient);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        .add-friend-btn:hover {
            background: linear-gradient(135deg, var(--brand-1), var(--brand-3));
            box-shadow: 0 6px 18px var(--brand-glow);
        }

        /* Friends Main Area Styles */
        .friends-main-area {
            display: flex;
            flex-direction: column;
            height: 100%;
            padding: 40px;
            background: var(--bg-primary);
            align-items: center;
            justify-content: center; /* center vertically */
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 20;
        }

        .friends-container {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 30px;
            max-width: 1000px;
            width: 100%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            margin: 0 auto; /* center horizontally */
        }

        .friends-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--brand-gradient);
        }

        .friends-header-main {
            text-align: center;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border-color);
            margin-bottom: 30px;
        }

        .friends-header-main h2 {
            color: var(--text-primary);
            margin: 0;
            font-size: 28px;
            font-weight: 700;
            background: var(--brand-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .friends-header-subtitle {
            color: var(--text-secondary);
            margin-top: 8px;
            font-size: 16px;
        }

        .friends-nav-main {
            display: flex;
            gap: 15px;
            margin-bottom: 40px;
            justify-content: center;
            background: var(--bg-primary);
            padding: 8px;
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .friends-nav-btn-main {
            background: transparent;
            color: var(--text-secondary);
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            position: relative;
            min-width: 120px;
        }

        .friends-nav-btn-main:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            transform: translateY(-1px);
        }

        .friends-nav-btn-main.active {
            background: var(--brand-gradient);
            color: white;
            box-shadow: 0 4px 12px var(--brand-glow);
        }

        .friends-nav-btn-main.active::before {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--brand-2);
        }

        /* Pending Requests badge + flashing */
        .pending-count-badge {
            background: var(--brand-gradient);
            color: #fff;
            border-radius: 10px;
            padding: 2px 8px;
            font-size: 12px;
            margin-left: 8px;
            box-shadow: 0 2px 6px var(--brand-glow);
            display: none; /* hidden when 0 */
        }
        @keyframes flash-text {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.35; }
        }
        .friends-nav-btn-main.has-pending .label {
            animation: flash-text 1s linear infinite;
            text-shadow: 0 0 8px var(--brand-glow);
            color: var(--text-primary);
        }

        .friends-content-main {
            flex: 1;
            overflow-y: auto;
            min-height: 400px;
        }

        .friends-tab-main {
            display: none;
        }

        .friends-tab-main.active {
            display: block;
        }

        /* Search Section */
        .search-section {
            margin-bottom: 30px;
            text-align: center;
        }

        .username-search-input {
            width: 100%;
            max-width: 600px;
            padding: 16px 20px;
            background: var(--bg-primary);
            border: 2px solid var(--border-color);
            border-radius: 10px;
            color: var(--text-primary);
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .username-search-input:focus {
            outline: none;
            border-color: var(--brand-2);
            box-shadow: 0 0 0 3px var(--brand-glow);
            transform: translateY(-1px);
        }

        .search-results-section {
            margin-top: 30px;
        }

        .username-search-results {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .search-placeholder {
            color: var(--text-secondary);
            text-align: center;
            padding: 60px;
            font-size: 18px;
            background: var(--bg-primary);
            border-radius: 8px;
            border: 2px dashed var(--border-color);
        }

        /* User Result Card */
        .user-result-card {
            display: flex;
            align-items: center;
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 10px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .user-result-card:hover {
            background: var(--bg-hover);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15), 0 0 0 2px var(--brand-glow);
            border-color: var(--brand-2);
        }

        .user-result-avatar {
            width: 50px;
            height: 50px;
            background: var(--brand-gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 18px;
            margin-right: 16px;
            box-shadow: 0 4px 12px var(--brand-glow);
            line-height: 1;
        }

        .user-result-info {
            flex: 1;
        }

        .user-result-username {
            color: var(--text-primary);
            font-weight: 700;
            font-size: 18px;
            margin-bottom: 4px;
        }

        .user-result-status {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .user-result-actions {
            display: flex;
            gap: 12px;
        }

        .quick-add-btn {
            background: var(--brand-gradient);
            color: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 700;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px var(--brand-glow);
            line-height: 1;
        }

        .quick-add-btn:hover {
            transform: scale(1.15);
            box-shadow: 0 6px 20px var(--brand-glow-strong);
        }

        /* Friends Grid */
        .friends-grid, .pending-requests-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
            gap: 12px;
        }

        .friend-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px;
            transition: background 0.2s ease, transform 0.12s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .friend-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--brand-gradient);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .friend-card:hover {
            background: var(--bg-hover);
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            border-color: var(--brand-2);
        }

        .friend-card:hover::before {
            opacity: 1;
        }

        .friend-card-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 10px;
        }
        /* Ensure inline Message button sits at the far right */
        .friend-card-header .friend-action-btn { margin-left: auto; }

        .friend-card-avatar {
            width: 40px;
            height: 40px;
            background: var(--brand-gradient);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 700;
            font-size: 16px;
            margin-right: 0;
            box-shadow: 0 4px 12px var(--brand-glow);
            line-height: 1;
        }

        .friend-card-info {
            flex: 1;
        }

        .friend-card-username {
            color: var(--text-primary);
            font-weight: 700;
            font-size: 15px;
            margin-bottom: 2px;
        }

        .friend-card-status {
            color: var(--text-secondary);
            font-size: 12px;
        }

        .friend-card-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 8px;
        }

        .friend-action-btn {
            background: var(--brand-gradient);
            color: #fff;
            border: none;
            padding: 6px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 700;
            transition: transform 0.12s ease, box-shadow 0.2s ease;
            min-width: 0;
            line-height: 1.1;
            box-shadow: 0 2px 8px var(--brand-glow);
        }

        .friend-action-btn:hover { transform: translateY(-1px); box-shadow: 0 4px 12px var(--brand-glow-strong); }

        .friend-action-btn.primary {
            background: var(--brand-gradient);
            color: white;
            border-color: transparent;
            box-shadow: 0 2px 8px var(--brand-glow);
        }

        .friend-action-btn.primary:hover {
            background: linear-gradient(135deg, var(--brand-1), var(--brand-3));
            box-shadow: 0 4px 12px var(--brand-glow-strong);
        }

        .friend-action-btn.danger {
            background: #dc3545;
            color: white;
            border-color: transparent;
            box-shadow: 0 2px 8px rgba(220, 53, 69, 0.3);
        }

        .friend-action-btn.danger:hover {
            background: #c82333;
            box-shadow: 0 4px 12px rgba(220, 53, 69, 0.4);
        }

        .user-profile-modal {
            background: #36393f;
            margin: 10% auto;
            padding: 0;
            border-radius: 8px;
            width: 500px;
            max-height: 88vh; /* allow tall content but keep within viewport */
            display: flex;
            flex-direction: column;
            color: white;
            overflow: hidden;
        }

        .profile-header {
            background: var(--brand-gradient);
            height: 160px;
            position: relative;
            background-size: cover;
            background-position: center;
        }

        .profile-avatar {
            position: absolute;
            bottom: -40px;
            left: 20px;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: var(--brand-gradient);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            font-weight: bold;
            border: 6px solid #36393f;
        }

        .profile-content {
            padding: 56px 20px 20px; /* standard padding, footer separate */
            display: flex;
            flex-direction: column;
            gap: 10px;
            flex: 1 1 auto;
            min-height: 0;
            overflow-y: auto;
        }
        /* Dedicated footer always at bottom */
        .profile-footer {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 12px 20px;
            border-top: 1px solid #202225;
            background: #2f3136;
        }
        .profile-footer .btn { min-width: 86px; }
        .profile-bio { color:#b9bbbe; margin: 6px 0 10px; white-space: pre-wrap; }
    /* Full profile bio box styling */
    .profile-bio-section { margin-top: 8px; display:none; }
    .profile-bio-section .bio-label-heading { font-size: 12px; font-weight: 600; letter-spacing: .5px; color:#8e9297; text-transform: uppercase; margin: 0 0 6px; }
    .profile-bio-box { background:#2f3136; border:1px solid #202225; border-radius:8px; padding:10px 12px; font-size:14px; line-height:1.4; color:#ffffff; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02); max-height:140px; overflow-y:auto; }
    .profile-bio-box::-webkit-scrollbar { width:10px; }
    .profile-bio-box::-webkit-scrollbar-thumb { background:#202225; border:3px solid #2f3136; border-radius:8px; }
    .profile-bio-box:empty::before { content:"No bio set."; font-style:italic; color:#6f7379; }
    /* Bio markdown styles */
    .profile-bio-box .bio-h1 { font-size:18px; margin:4px 0 6px; font-weight:600; }
    .profile-bio-box .bio-h2 { font-size:16px; margin:4px 0 4px; font-weight:600; }
    .profile-bio-box .bio-h3 { font-size:15px; margin:4px 0 4px; font-weight:600; opacity:.95; }
    .profile-bio-box .bio-p { margin:4px 0 8px; }
    /* Support raw sanitized heading tags (when storing HTML directly) */
    .profile-bio-box h3, .profile-bio-box h4, .profile-bio-box h5 { font-weight:600; margin:4px 0 6px; line-height:1.25; }
    .profile-bio-box h3, .profile-bio-box h4, .profile-bio-box h5, .profile-bio-box li, .profile-bio-box p { color:#ffffff; }
    .profile-bio { color:#ffffff; }
    /* Generic list support for HTML-stored bios */
    .profile-bio-box ul, .profile-bio-box ol { list-style-position: inside; margin:4px 0 8px; padding:0; }
    .profile-bio-box li { margin-left:0; padding-left:0; }
    /* Popover / mini profile bio container generic list styling */
    .profile-bio ul, .profile-bio ol { list-style-position: inside; margin:4px 0 8px; padding:0; }
    .profile-bio li { margin-left:0; padding-left:0; }
    .profile-bio-box ul.bio-list { list-style: disc inside; margin:4px 0 8px; padding:0; }
    .profile-bio-box ul.bio-list li { margin-left:4px; margin-bottom:2px; }
    .profile-bio-box .bio-code { background:#202225; padding:2px 5px; border-radius:4px; font-family:monospace; font-size:13px; }
    .profile-bio-box a.bio-link { color: var(--brand-3); text-decoration:none; }
    .profile-bio-box a.bio-link:hover { text-decoration:underline; }
    /* Bio Editor */
    .bio-editor-toolbar { display:flex; flex-wrap:wrap; gap:6px; margin-bottom:6px; }
        .bio-editor-toolbar { background:#2a2c31; padding:6px 8px; border:1px solid #202225; border-radius:8px; position:relative; }
        .bio-editor-toolbar button, .bio-editor-toolbar label, .bio-editor-toolbar select { 
            background:#32353b; border:1px solid #3c4047; color:#d6d7da; padding:4px 10px; font-size:12px; font-weight:600; border-radius:6px; cursor:pointer; line-height:1; display:flex; align-items:center; gap:4px; height:30px; box-shadow:0 1px 2px rgba(0,0,0,0.4) inset; transition:background .15s,border-color .15s,transform .1s; }
        .bio-editor-toolbar button:hover, .bio-editor-toolbar select:hover, .bio-editor-toolbar label:hover { background:#3d4047; border-color:#4a4f57; }
        .bio-editor-toolbar button:active { transform:translateY(1px); }
        .bio-editor-toolbar select { appearance:none; padding-right:22px; position:relative; }
    .bio-editor-toolbar::-webkit-scrollbar { height:8px; }
    .bio-editor-toolbar { overflow:hidden; flex-wrap: nowrap !important; white-space: nowrap; gap:6px; }
    .bio-editor-toolbar button, .bio-editor-toolbar select, .bio-editor-toolbar label { flex: 0 0 auto; min-width:40px; padding:4px 10px; justify-content:center; text-align:center; }
    .bio-editor-toolbar select { min-width:64px; }
    .bio-editor-toolbar .separator { width:1px; background:#202225; align-self:center; height:22px; flex:0 0 1px; }
    /* Compression levels */
    .bio-editor-toolbar.compressed-1 button, .bio-editor-toolbar.compressed-1 select, .bio-editor-toolbar.compressed-1 label { padding:3px 8px; font-size:11px; min-width:36px; }
    .bio-editor-toolbar.compressed-1 select { min-width:56px; }
    .bio-editor-toolbar.compressed-2 button, .bio-editor-toolbar.compressed-2 select, .bio-editor-toolbar.compressed-2 label { padding:2px 6px; font-size:10px; min-width:32px; }
    .bio-editor-toolbar.compressed-2 select { min-width:52px; }
    .bio-editor-toolbar.compressed-3 button, .bio-editor-toolbar.compressed-3 select, .bio-editor-toolbar.compressed-3 label { padding:1px 4px; font-size:9px; min-width:30px; }
    .bio-editor-toolbar.compressed-3 select { min-width:48px; }
    .bio-editor { background:#202225; border:1px solid #202225; border-radius:6px; padding:10px; min-height:120px; max-height:240px; overflow-y:auto; font-size:14px; line-height:1.4; white-space:pre-wrap; outline:none; color:#ffffff; }
    .bio-editor h3, .bio-editor h4, .bio-editor h5, .bio-editor p, .bio-editor span, .bio-editor li { color:inherit !important; }
    .bio-editor ul, .bio-editor ol { list-style-position: inside; padding-left:0; margin:4px 0 8px; }
    .bio-editor li { margin-left:0; }
    .bio-editor:focus { border-color: var(--brand-3); box-shadow:0 0 0 2px rgba(255,41,117,0.35); }
    .bio-editor .center { text-align:center; display:block; }
    .bio-editor span[data-color] { color:inherit; }
    .bio-editor-empty::before { content:'Start typing your bio...'; color:#6f7379; }
    .bio-color-input { width:28px; height:28px; padding:0; border:none; cursor:pointer; background:transparent; }
    .bio-editor-toolbar .separator { width:1px; background:#202225; margin:0 4px; align-self:stretch; }
    .bio-editor code { background:#18191c; padding:2px 4px; border-radius:4px; font-family:monospace; font-size:13px; }
    .bio-editor::-webkit-scrollbar { width:12px; }
    .bio-editor::-webkit-scrollbar-thumb { background:#2f3136; border:3px solid #202225; border-radius:8px; }
        .profile-servers { margin-top: 10px; }
        .profile-servers h4 { margin: 8px 0; font-size: 14px; color:#b9bbbe; }
        .profile-server-list { display:flex; gap:8px; flex-wrap: wrap; }
        .profile-server-chip { display:flex; align-items:center; gap:6px; background:#2f3136; border:1px solid #202225; border-radius:16px; padding:4px 8px; font-size:12px; color:#dcddde; }
        .profile-server-icon { width:18px; height:18px; border-radius:50%; background: var(--brand-2); background-size: cover; background-position: center; display:inline-block; font-weight:700; text-align:center; line-height:18px; color:white; }

    /* Mini Profile (lightweight profile peek) */
    .mini-profile.modal-content { width: 360px; max-width: 90vw; }
    .mini-profile-body { display: flex; flex-direction: column; gap: 10px; }
    .mini-profile-header { display: flex; align-items: center; gap: 12px; }
    .mini-profile-avatar { width: 64px; height: 64px; border-radius: 50%; background: var(--brand-gradient); display:flex; align-items:center; justify-content:center; font-weight:700; font-size: 24px; color:white; }
    .mini-profile-name { font-size: 18px; font-weight: 700; color: #fff; }
    .mini-profile-roles { margin-top: 6px; display:flex; align-items:center; gap:8px; flex-wrap: wrap; }
    .mini-profile-roles > * { vertical-align: middle; }
    .roles-label { font-size: 12px; color: #8e9297; text-transform: uppercase; margin-bottom: 6px; }
    .roles-inline-label { font-size: 12px; color: #8e9297; text-transform: uppercase; margin: 0; line-height: 1.6; }
    .role-chip-list { display: flex; gap: 6px; flex-wrap: wrap; }
    .role-chip-list.inline { display:flex; gap:6px; flex-wrap: wrap; }
    .mini-profile-roles .role-chip-list { flex: 1 1 auto; min-width: 0; }
    .roles-inline-label { flex: 0 0 auto; }
    .role-chip { display: inline-flex; align-items: center; gap: 6px; background: #2f3136; border: 1px solid #202225; border-radius: 12px; padding: 2px 8px; font-size: 12px; color: #dcddde; }
    .role-dot { width: 8px; height: 8px; border-radius: 50%; background: #5865f2; display: inline-block; }
    .profile-section-separator { height: 1px; background: var(--border-color); margin: 8px 0; border: none; }
    .bio-label { font-size: 12px; color: #8e9297; text-transform: uppercase; margin-bottom: 6px; }

    /* --- INLINE ROLES LAYOUT ENHANCEMENT (popover / mini preview) --- */
    /* Ensure label and chips share a single horizontal row */
    /* Inline roles: ensure label + chips share first line */
    .mini-profile-roles { flex-direction: row !important; align-items: center !important; }
    .mini-profile-roles .roles-label,
    .mini-profile-roles .roles-inline-label { margin: 0 8px 0 0 !important; line-height: 1; display: inline-block; flex: 0 0 auto; white-space: nowrap; }
    .mini-profile-roles .role-chip-list,
    .mini-profile-roles .role-chip-list.inline { display:flex; flex:1 1 auto; flex-wrap: wrap; gap:6px; min-width:0; overflow: visible; white-space: normal; }
    /* Remove horizontal scroll from earlier attempt */
    .mini-profile-roles .role-chip-list::-webkit-scrollbar,
    .mini-profile-roles .role-chip-list.inline::-webkit-scrollbar { height:0; }

    /* Floating Profile Popover (no overlay) */
    .profile-popover { position: fixed; z-index: 2600; background: #36393f; border: 1px solid #202225; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); width: 360px; max-width: 92vw; overflow: hidden; }
    .profile-popover .profile-header { height: 110px; }
    .profile-popover .profile-avatar { width: 64px; height: 64px; bottom: -32px; left: 16px; border-width: 4px; font-size: 24px; }
    .profile-popover .profile-content { padding: 44px 14px 14px; }
    .profile-popover .profile-servers h4 { font-size: 12px; }
    .profile-popover .profile-server-icon { width: 16px; height: 16px; line-height: 16px; font-size: 10px; }
    /* Smaller role chips inside popover and single-line scroll */
    .profile-popover .mini-profile-roles { flex-wrap: nowrap; }
    .profile-popover .role-chip-list.inline { overflow-x: auto; white-space: nowrap; flex: 1 1 auto; min-width: 0; }
    .profile-popover .role-chip { padding: 1px 6px; font-size: 11px; }
    .profile-popover .role-dot { width: 6px; height: 6px; }
    .profile-popover .role-chip-list.inline::-webkit-scrollbar { height: 6px; }
    .profile-popover .role-chip-list.inline::-webkit-scrollbar-track { background: transparent; }
    .profile-popover .role-chip-list.inline::-webkit-scrollbar-thumb { background: #202225; border-radius: 3px; }

        .profile-username {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .profile-email {
            color: #8e9297;
            margin-bottom: 20px;
        }

        /* Server Settings Modal */
        .server-settings-modal {
            max-width: 1100px; /* wider modal to give content more room */
        }

        /* New Server Settings Layout */
        .server-settings-layout {
            display: flex;
            gap: 8px; /* small gap while keeping near 10/90 ratio */
            min-height: 480px;
            width: 100%;
        }
        .settings-topbar {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 16px 16px 0 16px;
        }
        .settings-sidebar {
            flex: 0 0 10%; /* enforce 10% width for tabs */
            min-width: 100px; /* keep labels readable on small screens */
            border-right: 1px solid #202225;
            padding: 8px; /* compact padding */
            display: flex;
            flex-direction: column;
            align-items: stretch; /* buttons fill width */
            gap: 6px;
        }
        .settings-server-icon {
            width: 96px;
            height: 96px;
            border-radius: 50%;
            background: var(--brand-2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            background-size: cover;
            background-position: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .settings-server-icon:hover::after {
            content: 'Change';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        /* Account Settings avatar hover overlay (attach to the avatar itself for perfect fit) */
        .user-avatar.changeable-avatar { position: relative; overflow: hidden; }
        .user-avatar.changeable-avatar:hover::after {
            content: 'Change';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.45);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }
        .settings-nav {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .settings-nav-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            text-align: left;
            padding: 8px 10px; /* tighter padding */
            min-height: 32px; /* shorter button height */
            border: 1px solid transparent;
            border-radius: 6px;
            background: transparent;
            color: #b9bbbe;
            cursor: pointer;
            transition: background-color .12s ease, color .12s ease, border-color .12s ease, box-shadow .12s ease;
            font-size: 13px; /* slightly smaller font to fit better */
        }
        .settings-nav-btn:hover,
        .settings-nav-btn.active {
            background: #40444b;
            color: #ffffff;
            border-color: #4f545c;
        }
        .settings-nav-btn.active {
            box-shadow: inset 3px 0 0 #5865f2; /* left accent bar for active */
            font-weight: 600;
        }
        /* Delete tab as red text only, no border/background even when active */
        .settings-nav-btn.danger-link { color: #ff4d4f; border-color: transparent !important; }
        .settings-nav-btn.danger-link:hover { background: transparent; color: #ff6b6b; text-shadow: 0 0 8px rgba(255,77,79,0.3); }
        .settings-nav-btn.danger-link.active { background: transparent !important; box-shadow: none !important; color: #ff4d4f !important; border-color: transparent !important; }
        /* Danger button style */
        .btn-danger { background: #e03131; color: #fff; border: none; }
        .btn-danger:hover { background: #c92a2a; box-shadow: 0 2px 10px rgba(224,49,49,0.35); }
        /* Delete tab warning styles */
        .danger-panel { background: rgba(224,49,49,0.08); border: 1px solid rgba(224,49,49,0.35); padding: 16px; border-radius: 8px; }
        .danger-panel h3 { color: #ff6b6b; margin-bottom: 8px; }
        .danger-panel p { color: #ff8787; }
        /* Pop animation for removing server icons */
        @keyframes pop-out {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.08); opacity: 0.8; filter: saturate(1.2) drop-shadow(0 0 8px var(--brand-glow)); }
            100% { transform: scale(0.6); opacity: 0; }
        }
        .pop-out { animation: pop-out 240ms ease forwards; }
        .settings-content {
            flex: 1 1 90%; /* approx 90% content area */
            padding: 8px 0 8px 0; /* reduce internal padding */
            max-height: 74vh; /* a little more vertical space */
            overflow: auto;
        }

        .tab-content {
            display: none;
            padding: 20px 0;
            max-height: 500px;
            overflow-y: auto;
        }

        .tab-content.active {
            display: block;
        }

        .roles-section {
            padding: 10px 0;
        }

        .roles-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .roles-header h3 {
            margin: 0;
            color: white;
        }

        .role-form {
            background: #2f3136;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .permissions-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .permissions-list label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #dcddde;
            cursor: pointer;
        }

        .permissions-list input[type="checkbox"] {
            margin: 0;
        }

        .role-item {
            background: #2f3136;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .role-name {
            font-weight: bold;
            margin-right: 10px;
        }

        .role-actions {
            display: flex;
            gap: 10px;
        }

        .member-item {
            background: #2f3136;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .member-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .member-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--brand-gradient);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
        }

        .member-details {
            display: flex;
            flex-direction: column;
        }

        .member-username {
            font-weight: bold;
            margin-bottom: 4px;
        }

        .member-role {
            font-size: 12px;
            color: #b9bbbe;
        }

        .member-actions select {
            background: #40444b;
            color: white;
            border: 1px solid #72767d;
            border-radius: 4px;
            padding: 5px 10px;
        }

        .close-btn {
            background: none;
            border: none;
            color: #dcddde;
            font-size: 24px;
            cursor: pointer;
            float: right;
        }

        .close-btn:hover {
            color: white;
        }

        /* Slim inline layout for Members in Server Settings */
        .settings-content #server-members-list .member-item { display: flex; align-items: center; }
    .settings-content #server-members-list .member-info { display: inline-flex; flex-direction: row; align-items: center; gap: 8px; min-width: 0; }
        .settings-content #server-members-list .member-avatar { flex: 0 0 auto; }
    .settings-content #server-members-list .member-username { display: inline-block; flex: 1 1 auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Icon Cropper Modal */
        .cropper-modal {
            display: none;
            position: fixed;
            z-index: 3000; /* above other modals and image modal */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
        }
        .cropper-content {
            background: #2f3136;
            color: #dcddde;
            max-width: 520px;
            margin: 40px auto;
            border-radius: 8px;
            padding: 16px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        .cropper-header {
            font-size: 18px;
            margin-bottom: 12px;
        }
        .cropper-viewport {
            width: 256px;
            height: 256px;
            border-radius: 50%;
            margin: 0 auto 12px auto;
            position: relative;
            overflow: hidden; /* circular clip */
            box-shadow: 0 0 0 2px #202225, 0 0 0 6px rgba(0,0,0,0.2);
            background: #202225;
            touch-action: none;
        }
        .cropper-stage {
            position: absolute;
            left: 0; top: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
        }
        .cropper-stage.dragging { cursor: grabbing; }
        .cropper-img {
            will-change: transform;
            user-select: none;
            -webkit-user-drag: none;
            max-width: none; /* allow scaling beyond container */
        }
        .cropper-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            margin: 8px 0 12px 0;
            justify-content: center;
        }
        .cropper-slider { width: 70%; }
        .cropper-actions { display: flex; gap: 8px; justify-content: flex-end; }
    </style>
</head>
<body>
    <div class="discord-container">
        <!-- Server List -->
        <div class="server-list">
            <div class="server-icon home active" data-server="home" onclick="selectHome()">
                <img src="logo.svg" alt="Enyalis" style="width: 42px; height: 42px; object-fit: contain;">
            </div>
            <div class="server-separator"></div>
            <!-- User servers will be populated here -->
            <div id="user-servers"></div>
            <div class="server-icon add-server" onclick="showServerModal()" title="Add Server">+</div>
        </div>

        <!-- Channel Panel -->
        <div class="channel-panel">
            <div class="server-header" id="server-header">
                <span id="current-server-name" onclick="showServerMenu()" style="cursor: pointer; flex: 1;">Direct Messages</span>
                <div style="margin-left: auto; display: flex; gap: 8px;">
                    <button id="invite-btn" class="action-btn" onclick="showInviteModal()" style="display: none;" title="Invite People">
                        <img src="assets/icons/invite.svg" alt="Invite" class="icon-20" />
                    </button>
                </div>
            </div>
            
            <div class="channels-container">
                <!-- Friends section for home -->
                <div id="friends-section">
                    <div class="channel-category">Friends</div>
                    <ul class="channel-list" id="dm-list">
                        <li class="channel-item" onclick="showFriendsMain()" data-view="friends">
                            <span class="channel-icon friends"><img src="assets/icons/friends.svg" alt="Friends" class="icon-24" /></span>
                            Friends
                        </li>
                    </ul>
                    
                    <div class="channel-category">Direct Messages</div>
                    <ul class="channel-list" id="dm-conversations">
                        <!-- DM conversations will be populated here -->
                    </ul>
                </div>

                <!-- Server channels section -->
                <div id="server-channels-section" style="display: none;">
                    <div class="channel-category">
                        <span>Text Channels</span>
                        <button class="channel-manage-btn" id="add-channel-btn" onclick="showCreateChannelModal()" title="Create Channel">+</button>
                    </div>
                    <ul class="channel-list" id="text-channels-list"></ul>
                </div>
            </div>

            <div class="user-area" id="current-user-area" style="cursor:pointer;" title="View Profile / Settings" onclick="openOwnProfile(event)">
                <div class="user-info">
                    <div class="user-avatar" id="user-avatar"></div>
                    <div class="user-details">
                        <div class="username" id="current-username">Loading...</div>
                        <div class="user-status" id="current-user-status">Online</div>
                    </div>
                </div>
                <button class="action-btn" id="account-settings-btn" title="User Settings" onclick="event.stopPropagation(); openAccountSettings();" style="margin-left:auto;">
                    <img src="assets/icons/gear.svg" alt="Settings" class="icon-20" />
                </button>
            </div>
        </div>

        <!-- Chat Area -->
        <div class="chat-area" id="chat-area">
            <div class="chat-header">
                <span class="channel-icon" id="header-icon">#</span>
                <span class="channel-name" id="current-channel-name">Welcome</span>
                <span class="channel-info" id="current-channel-info">Select a server to get started</span>
            </div>

            <div class="messages-area" id="messages-container">
                <div class="welcome-message" id="default-welcome">
                    <h3>🎉 Welcome to Enyalis!</h3>
                    <p>Create a server or join one with an invite code to start chatting.</p>
                </div>
            </div>

            <!-- Message Input Area -->
            <div class="image-preview-area" id="image-preview-area">
                <div class="image-preview-container" id="image-preview-container"></div>
            </div>

            <div class="message-input-area" id="message-input-area" style="display: none;">
                <div class="message-input-container">
                    <input type="file" class="file-input" id="image-input" accept="image/*" multiple>
                    <input type="text" class="message-input" id="message-input" placeholder="Message...">
                    <div class="message-actions">
                        <button class="action-btn" onclick="document.getElementById('image-input').click()" title="Attach file(s)">
                            <img src="assets/icons/attach.svg" alt="Attach" class="icon-20" />
                        </button>
                        <button class="action-btn" id="send-btn" onclick="sendMessage()">➤</button>
                    </div>
                </div>
            </div>
            
            <!-- Central Friends UI -->
            <div class="friends-main-area" id="friends-main-area" style="display: none;">
                <div class="friends-container">
                    <div class="friends-header-main">
                        <h2>Friends</h2>
                        <div class="friends-header-subtitle">Manage your connections and discover new friends</div>
                    </div>
                    
                    <div class="friends-nav-main">
                        <button class="friends-nav-btn-main active" onclick="switchFriendsTab('current')">
                            Current Friends
                        </button>
                        <button class="friends-nav-btn-main" onclick="switchFriendsTab('add')">
                            Add Friends
                        </button>
                        <button class="friends-nav-btn-main" id="friends-tab-pending-btn" onclick="switchFriendsTab('pending')">
                            <span class="label">Pending Requests</span>
                            <span class="pending-count-badge" id="pending-count-badge">0</span>
                        </button>
                    </div>
                    
                    <div class="friends-content-main">
                        <!-- Current Friends Tab -->
                        <div id="current-friends-content" class="friends-tab-main active">
                            <div class="friends-grid" id="current-friends-grid">
                                <!-- Current friends will be loaded here -->
                            </div>
                        </div>
                        
                        <!-- Add Friends Tab -->
                        <div id="add-friends-content" class="friends-tab-main">
                            <div class="search-section">
                                <input 
                                    type="text" 
                                    id="username-search-input" 
                                    placeholder="Enter username to search..." 
                                    class="username-search-input"
                                >
                            </div>
                            <div class="search-results-section">
                                <div id="username-search-results" class="username-search-results">
                                    <div class="search-placeholder">Enter a username to find friends</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Pending Requests Tab -->
                        <div id="pending-requests-content" class="friends-tab-main">
                            <div class="pending-requests-grid" id="pending-requests-grid">
                                <!-- Pending requests will be loaded here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Members Panel -->
        <div class="members-panel" id="members-panel" style="display: none;">
            <div class="members-header">
                <span>Members</span>
                <span class="members-count" id="members-count">0</span>
            </div>
            <div class="members-list" id="members-list">
                <!-- Members will be populated here -->
            </div>
        </div>
        
        <!-- Floating Members Toggle Button -->
        <button class="members-toggle-btn" id="members-toggle" onclick="toggleMembersPanel()" title="Toggle Members" style="display: none;">
            <span class="arrow">◄</span>
        </button>
    </div>

    <!-- Image Modal -->
    <div id="image-modal" class="image-modal" onclick="closeImageModal()">
        <img id="modal-image" src="" alt="">
    </div>

    <!-- Profile Popover (no overlay) -->
    <div id="profile-popover" class="profile-popover" style="display:none;">
        <div class="user-profile-modal" style="margin:0; width:auto;">
            <div class="profile-header" id="popover-profile-header">
                <div class="profile-avatar" id="popover-profile-avatar"></div>
            </div>
            <div class="profile-content">
                <div class="profile-username" id="popover-profile-username"></div>
                <div class="mini-profile-roles" id="popover-roles">
                    <span class="roles-inline-label">ROLES</span>
                    <div class="role-chip-list inline" id="popover-role-list"></div>
                </div>
                <hr class="profile-section-separator" id="popover-roles-sep" style="display:none;" />
                <div id="popover-bio-wrap" style="display:none;">
                    <div class="bio-label">Bio</div>
                    <div class="profile-bio" id="popover-profile-bio"></div>
                </div>
                <div class="profile-servers" id="popover-profile-servers" style="display:none;">
                    <h4>Servers</h4>
                    <div class="profile-server-list" id="popover-profile-server-list"></div>
                </div>
                <div class="modal-actions" style="justify-content:flex-end; gap:8px;">
                    <button type="button" class="btn btn-primary" onclick="openFullProfileFromPopover()">Open Full</button>
                </div>
            </div>
        </div>
    </div>
    <!-- Mini Profile Modal -->
    <div id="mini-profile-modal" class="modal">
        <div class="modal-content mini-profile">
            <div class="modal-header">Profile</div>
            <div class="mini-profile-body">
                <div class="mini-profile-header">
                    <div class="mini-profile-avatar" id="mini-profile-avatar"></div>
                    <div class="mini-profile-name" id="mini-profile-username"></div>
                </div>
                <div class="mini-profile-roles">
                    <div class="roles-label">Roles</div>
                    <div class="role-chip-list" id="mini-profile-roles"></div>
                </div>
                <div class="modal-actions" style="justify-content: space-between;">
                    <button type="button" class="btn btn-secondary" onclick="closeMiniProfile()">Close</button>
                    <button type="button" class="btn btn-primary" onclick="openFullProfileFromMini()">View Full Profile</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Unified Server Modal -->
    <div id="server-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <span id="server-modal-title">Add Server</span>
            </div>
            
            <!-- Tab Navigation -->
            <div class="server-modal-tabs">
                <button class="server-tab-btn active" id="create-tab-btn" onclick="switchServerTab('create')">
                    Create Server
                </button>
                <button class="server-tab-btn" id="join-tab-btn" onclick="switchServerTab('join')">
                    Join Server
                </button>
            </div>
            
            <!-- Create Server Tab -->
            <div id="create-server-tab" class="server-tab-content active">
                <form id="create-server-form" onsubmit="createServer(event)">
                    <div class="form-group">
                        <label class="form-label">Server Name</label>
                        <input type="text" class="form-input" id="server-name" placeholder="Enter server name" required>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Server Description</label>
                        <input type="text" class="form-input" id="server-description" placeholder="What's your server about?">
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="hideServerModal()">Cancel</button>
                        <button type="submit" class="btn btn-primary">Create Server</button>
                    </div>
                </form>
            </div>
            
            <!-- Join Server Tab -->
            <div id="join-server-tab" class="server-tab-content">
                <form id="join-server-form" onsubmit="joinServer(event)">
                    <div class="form-group">
                        <label class="form-label">Invite Code or Link</label>
                        <input type="text" class="form-input" id="invite-code" placeholder="Enter invite code (e.g., ABC123) or paste invite link" required>
                        <small class="form-help">You can paste a full invite link or just enter the code</small>
                    </div>
                    <div class="modal-actions">
                        <button type="button" class="btn btn-secondary" onclick="hideServerModal()">Cancel</button>
                        <button type="submit" class="btn btn-primary">Join Server</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Add Friend Modal -->
    <div id="add-friend-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Add Friend</div>
            <form id="add-friend-form" onsubmit="sendFriendRequest(event)">
                <div class="form-group">
                    <label class="form-label">Username or Email</label>
                    <input type="text" class="form-input" id="friend-identifier" placeholder="Enter username or email" required>
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="hideAddFriendModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Send Request</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Server Invite Modal -->
    <div id="server-invite-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Invite People to <span id="invite-server-name"></span></div>
            <div class="form-group">
                <label class="form-label">Share this invite link</label>
                <div style="display: flex; gap: 8px;">
                    <input type="text" class="form-input" id="invite-link" readonly>
                    <button type="button" class="btn btn-primary" id="copy-invite-btn" onclick="copyInviteLink()">Copy</button>
                </div>
                <div style="font-size: 12px; color: #8e9297; margin-top: 8px;">
                    This invite link never expires and can be used by anyone.
                </div>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="hideInviteModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Server Preview Modal (for invite links) -->
    <div id="server-preview-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Join Server</div>
            <div class="server-preview-content">
                <div class="server-preview-icon">
                    <div class="server-icon-large" id="preview-server-icon"></div>
                </div>
                <div class="server-preview-info">
                    <h3 id="preview-server-name">Server Name</h3>
                    <p id="preview-server-description">Server description goes here...</p>
                    <div class="server-preview-stats">
                        <span id="preview-member-count">0 members</span>
                    </div>
                </div>
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="hideServerPreviewModal()">Cancel</button>
                <button type="button" class="btn btn-primary" id="join-server-btn" onclick="joinServerFromPreview()">Join Server</button>
            </div>
        </div>
    </div>

    <!-- Server Icon Cropper Modal -->
    <div id="icon-cropper-modal" class="cropper-modal">
        <div class="cropper-content">
            <div class="cropper-header">Adjust Server Icon</div>
            <div class="cropper-viewport" id="cropper-viewport">
                <div class="cropper-stage" id="cropper-stage">
                    <img id="cropper-img" class="cropper-img" alt="icon to crop" />
                </div>
            </div>
            <div class="cropper-controls">
                <span style="font-size:12px; color:#8e9297;">Zoom</span>
                <input id="cropper-zoom" class="cropper-slider" type="range" min="0.5" max="3" step="0.01" value="1" />
                <span id="cropper-zoom-value" style="font-size:12px; color:#8e9297; width:40px; text-align:right;">1.00×</span>
            </div>
            <div class="cropper-actions">
                <button type="button" class="btn btn-secondary" onclick="hideIconCropper()">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="applyIconCrop()">Save Icon</button>
            </div>
        </div>
    </div>

    <!-- Create Channel Modal -->
    <div id="create-channel-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">Create Channel</div>
            <form onsubmit="createChannel(event)">
                <div class="form-group">
                    <label class="form-label">Channel Name</label>
                    <input type="text" class="form-input" id="channel-name" placeholder="new-channel" required>
                    <div class="form-help">Channel names must be lowercase and can contain letters, numbers, and hyphens.</div>
                </div>
                <div class="form-group">
                    <label class="form-label">Channel Description</label>
                    <input type="text" class="form-input" id="channel-description" placeholder="What's this channel about?">
                </div>
                <div class="modal-actions">
                    <button type="button" class="btn btn-secondary" onclick="hideCreateChannelModal()">Cancel</button>
                    <button type="submit" class="btn btn-primary">Create Channel</button>
                </div>
            </form>
        </div>
    </div>

    <!-- User Profile Modal -->
    <div id="user-profile-modal" class="modal">
        <div class="user-profile-modal">
            <div class="profile-header" id="profile-header">
                <div class="profile-avatar" id="profile-avatar"></div>
            </div>
            <div class="profile-content">
                <div class="profile-username" id="profile-username"></div>
                <div class="profile-email" id="profile-email"></div>
                <div class="profile-bio-section" id="profile-bio-section" style="display:none;">
                    <div class="bio-label-heading">Bio</div>
                    <div class="profile-bio-box" id="profile-bio"></div>
                </div>
                <div class="profile-servers" id="profile-servers" style="display:none;">
                    <h4>Servers</h4>
                    <div class="profile-server-list" id="profile-server-list"></div>
                </div>
            </div>
            <div class="profile-footer" id="profile-modal-actions">
                <button type="button" class="btn btn-primary" id="profile-add-friend-btn" onclick="sendFriendRequestToProfile()">Add Friend</button>
                <button type="button" class="btn btn-secondary" id="profile-close-btn" onclick="hideUserProfile()">Close</button>
            </div>
        </div>
    </div>

    <!-- Server Settings Modal -->
    <div id="server-settings-modal" class="modal">
    <div class="modal-content" style="max-width: 1100px; max-height: 90vh; overflow: hidden;">
            <div class="modal-header">
                <span id="server-settings-title">Server Settings</span>
                <button type="button" class="close-btn" onclick="hideServerSettings()">&times;</button>
            </div>
            <div class="settings-topbar">
                <div class="settings-server-icon" id="server-settings-icon" title="Click to change icon"></div>
                <input type="file" id="server-icon-input" accept="image/*" style="display:none">
            </div>
            
            <div class="server-settings-layout">
                <aside class="settings-sidebar">
                    <nav class="settings-nav">
                        <button class="settings-nav-btn active" data-tab="general" onclick="switchServerSettingsTab('general')">General</button>
                        <button class="settings-nav-btn" data-tab="members" onclick="switchServerSettingsTab('members')">Members</button>
                        <button class="settings-nav-btn" data-tab="roles" onclick="switchServerSettingsTab('roles')">Roles</button>
                        <button class="settings-nav-btn" data-tab="kick" onclick="switchServerSettingsTab('kick')">Kick</button>
                        <button class="settings-nav-btn" data-tab="admins" onclick="switchServerSettingsTab('admins')">Admins</button>
                        <div style="height:8px;"></div>
                        <button class="settings-nav-btn danger-link" data-tab="delete" onclick="switchServerSettingsTab('delete')">Delete Server</button>
                    </nav>
                </aside>
                <section class="settings-content">
                    <!-- General Settings Tab -->
                    <div id="general-tab" class="tab-content active">
                        <form onsubmit="updateServerSettings(event)" style="max-width:520px; margin: 12px auto 0;">
                            <div class="form-group">
                                <label class="form-label">Name</label>
                                <input type="text" class="form-input" id="edit-server-name" placeholder="Server Name" required>
                            </div>
                            <div class="form-group">
                                <label class="form-label">Description</label>
                                <textarea class="form-input" id="edit-server-description" placeholder="Tell people about your server" rows="3" maxlength="190"></textarea>
                            </div>
                            <div class="form-group">
                                <!-- Server image handled by clicking the icon above -->
                            </div>
                            <div class="modal-actions" style="justify-content:flex-end;">
                                <button type="submit" class="btn btn-primary">Save Changes</button>
                            </div>
                        </form>
                    </div>
                    
                    <!-- Members Management Tab -->
                    <div id="members-tab" class="tab-content">
                        <div class="members-list-container" style="max-height: 400px; overflow-y: auto;">
                            <div id="server-members-list">
                                <!-- Members will be populated here -->
                            </div>
                        </div>
                    </div>
                    
                    <!-- Roles Management Tab -->
                    <div id="roles-tab" class="tab-content">
                        <div class="roles-section">
                            <div class="roles-header">
                                <h3>Roles</h3>
                                <button type="button" class="btn btn-primary btn-sm" onclick="showCreateRoleForm()">Create Role</button>
                            </div>
                            
                            <!-- Create Role Form (initially hidden) -->
                            <div id="create-role-form" class="role-form" style="display: none;">
                                <form onsubmit="createRole(event)">
                                    <div class="form-group">
                                        <label class="form-label">Role Name</label>
                                        <input type="text" class="form-input" id="new-role-name" placeholder="Role Name" required>
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Role Color</label>
                                        <input type="color" class="form-input" id="new-role-color" value="#5865f2">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Permissions</label>
                                        <div class="permissions-list">
                                            <label><input type="checkbox" id="perm-manage-channels"> Manage Channels</label>
                                            <label><input type="checkbox" id="perm-manage-members"> Manage Members</label>
                                            <label><input type="checkbox" id="perm-kick-members"> Kick Members</label>
                                            <label><input type="checkbox" id="perm-ban-members"> Ban Members</label>
                                            <label><input type="checkbox" id="perm-create-invite"> Create Invite</label>
                                        </div>
                                    </div>
                                    <div class="modal-actions">
                                        <button type="button" class="btn btn-secondary" onclick="hideCreateRoleForm()">Cancel</button>
                                        <button type="submit" class="btn btn-primary">Create Role</button>
                                    </div>
                                </form>
                            </div>
                            
                            <div id="roles-list">
                                <!-- Roles will be populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- Kick Members Tab -->
                    <div id="kick-tab" class="tab-content">
                        <div class="members-list-container" style="max-height: 400px; overflow-y: auto;">
                            <div id="kick-members-list"></div>
                        </div>
                        <p id="kick-permission-note" style="color: #b9bbbe; font-size: 12px; margin-top: 8px;"></p>
                    </div>

                    <!-- Admins Management Tab -->
                    <div id="admins-tab" class="tab-content">
                        <div class="members-list-container" style="max-height: 400px; overflow-y: auto;">
                            <div id="admins-list"></div>
                        </div>
                        <p id="admins-permission-note" style="color: #b9bbbe; font-size: 12px; margin-top: 8px;"></p>
                    </div>

                    <!-- Delete Server Tab -->
                    <div id="delete-tab" class="tab-content">
                        <div class="danger-panel">
                            <h3>Danger Zone</h3>
                            <p>Deleting a server is permanent. This will remove the server, its channels, messages, roles, and kick all members. This action cannot be undone.</p>
                        </div>
                        <div class="modal-actions" style="justify-content: space-between; margin-top: 16px;">
                            <div style="color:#ff8787; font-size:12px;" id="delete-owner-note">Only the server owner can delete this server.</div>
                            <button type="button" id="delete-server-open-btn" class="btn btn-danger" onclick="openDeleteServerConfirm()">Delete Server</button>
                        </div>
                    </div>
                </section>
            </div>
        </div>
    </div>

    <!-- Account Settings Modal -->
    <div id="account-settings-modal" class="modal" style="display:none;">
        <div class="modal-content" style="width: 760px; max-width: 96vw; height: 80vh; max-height: 90vh; display:flex; flex-direction:column; position:relative;">
            <div class="modal-header" style="display:flex; align-items:center; justify-content:space-between; flex:0 0 auto; gap:12px;">
                <span style="flex:1;">Account Settings</span>
                <div style="display:flex; gap:8px;">
                    <button class="btn btn-primary" onclick="document.getElementById('account-profile-form').requestSubmit();" style="min-width:110px;">Save</button>
                    <button class="btn btn-secondary" onclick="closeAccountSettings()" style="min-width:80px;">Close</button>
                </div>
            </div>
            <div class="account-settings-body" style="display:flex; gap:16px; flex:1 1 auto; min-height:0; overflow:hidden;">
                <div style="flex: 0 0 240px; border-right: 1px solid var(--border-color); padding-right: 12px; overflow:auto;">
                    <div style="color:#b9bbbe; font-size:12px; margin-bottom:6px;">USER SETTINGS</div>
                    <button class="friends-nav-btn-main" style="width:100%; text-align:left;" onclick="showAccountSection('profile')">Profile</button>
                    <button class="friends-nav-btn-main" style="width:100%; text-align:left;" onclick="showAccountSection('voice')">Voice & Audio</button>
                </div>
                <div id="account-settings-content" style="flex:1 1 auto; overflow:auto; padding-right: 4px;">
                    <div id="account-section-profile">
                        <div style="display:flex; flex-direction:column; align-items:center; gap:12px; padding-top:8px;">
                            <div id="account-avatar-preview" class="user-avatar changeable-avatar" style="width:96px; height:96px; font-size:34px; cursor:pointer;" title="Click to change avatar" onclick="triggerAccountAvatarPick()">A</div>
                            <div style="display:flex; gap:8px;">
                                <button type="button" class="btn btn-sm btn-secondary" onclick="clearAccountAvatar()">Remove</button>
                                <input id="account-avatar-file" type="file" accept="image/*" style="display:none;" />
                            </div>
                            <div style="margin-top:8px; width:100%; max-width:520px;">
                                <label class="form-label">Profile Banner (image or GIF)</label>
                                <div id="account-banner-preview" style="height:120px; border-radius:8px; background:linear-gradient(90deg,#5865F2,#FF2241); background-size:cover; background-position:center; display:flex; align-items:center; justify-content:center; color:#ffffff88; cursor:pointer;" title="Click to change banner" onclick="triggerAccountBannerPick()">Click to set banner</div>
                                <div style="display:flex; gap:8px; margin-top:6px;">
                                    <button type="button" class="btn btn-sm btn-secondary" onclick="clearAccountBanner()">Remove Banner</button>
                                    <input id="account-banner-file" type="file" accept="image/*" style="display:none;" />
                                </div>
                            </div>
                        </div>
                        <form id="account-profile-form" onsubmit="return saveAccountProfile(event)" style="margin-top:16px; max-width:520px; margin-left:auto; margin-right:auto;">
                            <div class="form-group">
                                <label class="form-label">Name</label>
                                <input id="account-username-input" class="form-input" placeholder="Your name" />
                            </div>
                            <div class="form-group">
                                <label class="form-label">Bio (rich)</label>
                                <div class="bio-editor-toolbar">
                                    <button type="button" onclick="bioExec('bold')" title="Bold"><b>B</b></button>
                                    <button type="button" onclick="bioExec('italic')" title="Italic"><em>I</em></button>
                                    <button type="button" onclick="bioApplyHeading(3)" title="Heading 1">H1</button>
                                    <button type="button" onclick="bioApplyHeading(4)" title="Heading 2">H2</button>
                                    <button type="button" onclick="bioApplyHeading(5)" title="Heading 3">H3</button>
                                    <div class="separator"></div>
                                    <button type="button" onclick="bioInsertList()" title="Bulleted List">• List</button>
                                    <button type="button" onclick="bioCenter()" title="Center Selection">Center</button>
                                    <!-- Color & highlight controls removed -->
                                    <select onchange="bioFontSize(this.value)" title="Font Size">
                                        <option value="">Size</option>
                                        <option>12</option><option>14</option><option>16</option><option>18</option><option>20</option><option>22</option><option>24</option>
                                    </select>
                                    <button type="button" onclick="bioClearFormatting()" title="Clear Formatting">Clear</button>
                                </div>
                                <div id="account-bio-editor" class="bio-editor" contenteditable="true" data-placeholder="Start typing your bio..."></div>
                                <input type="hidden" id="account-bio-input" />
                                <div style="font-size:11px; color:#6f7379; margin-top:4px;">Tab inserts 4 spaces • Max 1000 characters (after sanitization)</div>
                            </div>
                            <!-- Footer removed from inside scroll; global footer now used -->
                        </form>
                    </div>
                    <div id="account-section-voice" style="display:none;">
                        <h3 style="margin: 4px 0 12px 0;">Voice & Audio</h3>
                        <p style="color:#b9bbbe;">Coming soon. Configure microphone, input/output devices, and push-to-talk here.</p>
                    </div>
                </div>
            </div>
            <!-- Removed bottom footer; Save/Close now in header -->
        </div>
    </div>

    <!-- Delete Server: Step 1 Confirm Modal -->
    <div id="delete-server-confirm-modal" class="modal">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header">Delete Server</div>
            <div style="color:#dcddde; line-height:1.5;">
                You are about to delete <strong id="del-modal-server-name-1"></strong>. This action cannot be undone.
            </div>
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="cancelDeleteServerFlow()">Cancel</button>
                <button type="button" class="btn btn-danger" onclick="proceedDeleteServerVerify()">I understand</button>
            </div>
        </div>
    </div>

    <!-- Delete Server: Step 2 Verify Modal -->
    <div id="delete-server-verify-modal" class="modal">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header">Type to Confirm</div>
            <div style="color:#dcddde; line-height:1.5; margin-bottom:12px;">
                Please type the server name <strong id="del-modal-server-name-2"></strong> to confirm deletion.
            </div>
            <input id="delete-server-name-input" class="form-input" placeholder="Server name" />
            <div class="modal-actions">
                <button type="button" class="btn btn-secondary" onclick="cancelDeleteServerFlow()">Cancel</button>
                <button type="button" id="confirm-delete-server-btn" class="btn btn-danger" disabled onclick="performDeleteServer()">Delete</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let socket;
        let currentUser = null;
        let currentServer = null;
        let currentChannel = null;
        let userServers = [];
        let friends = [];
        let friendRequests = { incoming: [], outgoing: [] };
        let allUsers = [];
        let currentView = 'welcome';
        let currentProfileUser = null;
    let currentDMUser = null;
        // Track last observed server-deleted event to reconcile DELETE responses
    let lastDeletedServerEvent = { id: null, at: 0 };
    // Track a locally-initiated delete to suppress duplicate socket toasts/UI
    let pendingLocalServerDelete = { id: null, at: 0 };
    // Cache of current server members for quick role lookup: userId -> { role, roleId }
    let currentServerMembersMap = new Map();
    // Track which server the members cache belongs to
    let currentServerMembersCacheServerId = null;
    // Cache of server roles: serverId -> { [roleId]: role }
    const serverRolesCache = new Map();

        async function loadServerMembersCache(serverId) {
            try {
                const resp = await fetch(`/api/servers/${serverId}/members`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                if (!resp.ok) {
                    currentServerMembersMap = new Map();
                    currentServerMembersCacheServerId = null;
                    return;
                }
                const data = await resp.json();
                const map = new Map();
                (data.members || []).forEach(m => {
                    map.set(parseInt(m.userId), { role: m.role, roleId: m.roleId ?? null });
                });
                currentServerMembersMap = map;
                currentServerMembersCacheServerId = parseFloat(serverId);
            } catch {
                currentServerMembersMap = new Map();
                currentServerMembersCacheServerId = null;
            }
        }

        // Load roles into cache for a server
        async function loadServerRolesCache(serverId) {
            try {
                const resp = await fetch(`/api/servers/${serverId}/roles`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                if (!resp.ok) { serverRolesCache.delete(parseFloat(serverId)); return; }
                const data = await resp.json();
                const map = {};
                (data.roles || []).forEach(r => { map[r.id] = r; });
                serverRolesCache.set(parseFloat(serverId), map);
            } catch {
                serverRolesCache.delete(parseFloat(serverId));
            }
        }

        // Resolve role color synchronously from caches (members + roles cache); returns fallback if missing
        function getRoleColorFromCaches(userId) {
            let fallback = '#dcddde';
            if (!currentServer || !userId) return fallback;
            const member = currentServerMembersMap.get(parseInt(userId));
            if (!member) return fallback;
            const rolesMap = serverRolesCache.get(parseFloat(currentServer.id)) || {};
            if (member.roleId && rolesMap[member.roleId] && rolesMap[member.roleId].color) {
                return rolesMap[member.roleId].color;
            }
            if (member.role === 'owner') return '#43b581';
            if (member.role === 'admin') return '#7289da';
            return fallback;
        }

        async function getRoleColorForUserId(userId) {
            // Default color
            let fallback = '#dcddde';
            if (!currentServer || !userId) return fallback;
            const member = currentServerMembersMap.get(parseInt(userId));
            if (!member) return fallback;
            // Prefer custom role color
            const rolesMap = await getServerRolesMap();
            if (member.roleId && rolesMap[member.roleId] && rolesMap[member.roleId].color) {
                return rolesMap[member.roleId].color;
            }
            if (member.role === 'owner') return '#43b581';
            if (member.role === 'admin') return '#7289da';
            return fallback;
        }

        async function applyRoleColorToAuthorElement(authorEl, userId) {
            if (!authorEl || !userId || !currentServer) return;
            // Ensure cache corresponds to current server
            if (!currentServerMembersMap || currentServerMembersMap.size === 0 || currentServerMembersCacheServerId !== parseFloat(currentServer.id)) {
                await loadServerMembersCache(currentServer.id);
            }
            // Ensure roles cache is warmed; then compute color from caches
            if (!serverRolesCache.has(parseFloat(currentServer.id))) {
                await loadServerRolesCache(currentServer.id);
            }
            const color = getRoleColorFromCaches(userId);
            authorEl.style.color = color;
        }

        // Helper: recolor all visible message authors using current cache
        async function recolorAllVisibleAuthors() {
            try {
                if (!currentServer) return;
                if (!currentServerMembersMap || currentServerMembersMap.size === 0 || currentServerMembersCacheServerId !== parseFloat(currentServer.id)) {
                    await loadServerMembersCache(currentServer.id);
                }
                const authors = document.querySelectorAll('#messages-container .message-author');
                for (const el of authors) {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                }
            } catch (e) {
                console.error('recolorAllVisibleAuthors failed:', e);
            }
        }

        // Authentication check
        async function validateSession() {
            const token = localStorage.getItem('token');
            if (!token) {
                redirectToLandingWithError('Please log in to access the chat.');
                return false;
            }

            try {
                const response = await fetch('/api/users/validate', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error('Session validation failed');
                }

                const userData = await response.json();
                currentUser = userData.user;
                return true;
            } catch (error) {
                console.error('Session validation error:', error);
                localStorage.removeItem('token');
                redirectToLandingWithError('Your session has expired. Please log in again.');
                return false;
            }
        }

        function redirectToLandingWithError(message) {
            localStorage.setItem('authError', message);
            window.location.href = '/';
        }

        // Initialize everything on page load
        window.addEventListener('DOMContentLoaded', async () => {
            const isAuthenticated = await validateSession();
            if (!isAuthenticated) {
                return;
            }

            // Update UI with current user info
            document.getElementById('current-username').textContent = currentUser.username;
            const userAvatarElInit = document.getElementById('user-avatar');
            if (userAvatarElInit) {
                if (currentUser.avatar) {
                    userAvatarElInit.style.backgroundImage = `url(${currentUser.avatar})`;
                    userAvatarElInit.style.backgroundSize = 'cover';
                    userAvatarElInit.style.backgroundPosition = 'center';
                    userAvatarElInit.style.backgroundRepeat = 'no-repeat';
                    userAvatarElInit.style.backgroundColor = 'transparent';
                    userAvatarElInit.textContent = '';
                } else {
                    userAvatarElInit.style.backgroundImage = '';
                    userAvatarElInit.textContent = currentUser.username.charAt(0).toUpperCase();
                }
            }
            
            // Initialize Socket.IO and load data
            initializeSocket();
            loadUserServers();
            // Initialize with friends view
            showFriendsMain();
            loadDMConversations();
            // Initialize pending requests badge once at startup
            updatePendingRequestsBadge().catch(() => {});
            
            // Check for invite code in URL and show preview modal
            const urlParams = new URLSearchParams(window.location.search);
            const inviteCode = urlParams.get('invite');
            if (inviteCode) {
                await showServerPreview(inviteCode);
                // Clean up URL without invite parameter
                const newUrl = window.location.origin + window.location.pathname;
                window.history.replaceState({}, document.title, newUrl);
            }
            
            // Set up message input event listener
            document.getElementById('message-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    sendMessage();
                }
            });
            // Click anywhere on the container to focus the text input
            const msgContainer = document.querySelector('.message-input-container');
            const msgInput = document.getElementById('message-input');
            if (msgContainer && msgInput) {
                msgContainer.addEventListener('click', (e) => {
                    // Avoid stealing focus from buttons if they were the exact target
                    const tag = e.target.tagName.toLowerCase();
                    if (tag === 'button' || tag === 'img' || tag === 'input') return;
                    msgInput.focus();
                });
            }
            
            // Set up image input change listener
            document.getElementById('image-input').addEventListener('change', handleImageSelection);
        });

        function initializeSocket() {
            const token = localStorage.getItem('token');
            socket = io({
                auth: {
                    token: token
                }
            });
            
            socket.on('connect', () => {
                console.log('Connected to server with authentication');
            });

            socket.on('connect_error', (error) => {
                console.error('Socket connection failed:', error);
                redirectToLandingWithError('Authentication failed. Please log in again.');
            });
            
            socket.on('new-message', async (message) => {
                console.log('Received new message via socket:', message);
                console.log('Current channel:', currentChannel);
                if (currentChannel && parseInt(message.channelId) === parseInt(currentChannel.id)) {
                    console.log('Adding message to UI');
                    await addMessageToUI(message);
                } else {
                    console.log('Message not for current channel or no current channel');
                    console.log('Message channel ID:', message.channelId, 'Current channel ID:', currentChannel?.id);
                }
            });

            // Attach edit/delete listeners after socket is ready
            attachEditDeleteSocketListeners();
            
            // Listen for friend request notifications
            socket.on('friend-request-received', (data) => {
                console.log('Friend request received:', data);
                showNotification(data.message, 'success');
                // Update friend requests badge and reload pending requests if on friends page
                updatePendingRequestsBadge();
                if (currentView === 'friends') {
                    loadPendingRequestsMain();
                }
            });
            

            // Listen for server kick notifications
            socket.on('server-kicked', (data) => {
                try {
                    const kickedServerId = parseFloat(data.serverId);
                    console.log('Received server-kicked event for server:', kickedServerId);

                    // Find server name before removing
                    const idx = userServers.findIndex(s => parseFloat(s.id) === kickedServerId);
                    const serverName = idx !== -1 ? userServers[idx].name : `Server ${kickedServerId}`;

                    // If the kicked server is currently open, move user to Friends view first
                    if (currentServer && parseFloat(currentServer.id) === kickedServerId) {
                        if (socket && currentChannel && currentChannel.id) {
                            socket.emit('leave-channel', currentChannel.id);
                        }
                        selectHome();
                    }

                    // Remove from local server list and refresh sidebar
                    userServers = userServers.filter(s => parseFloat(s.id) !== kickedServerId);
                    displayUserServers();

                    // Close server settings if open
                    const settingsModal = document.getElementById('server-settings-modal');
                    if (settingsModal && settingsModal.style.display === 'block') {
                        hideServerSettings();
                    }

                    showNotification(`You were removed from "${serverName}"`, 'error');
                } catch (e) {
                    console.error('Error handling server-kicked event:', e);
                }
            });

            // Notify remaining members to refresh UI when member changes occur (e.g., kicked)
            socket.on('server-member-updated', (data) => {
                try {
                    const sid = parseFloat(data.serverId);
                    if (!currentServer || parseFloat(currentServer.id) !== sid) return;
                    console.log('server-member-updated:', data);

                    // Refresh members cache and any visible members-related tabs
                    Promise.all([
                        loadServerMembersCache(sid),
                        loadServerRolesCache(sid)
                    ]).then(async () => {
                        // If settings modal is open on members/kick/admins tab, refresh lists
                        const settingsModal = document.getElementById('server-settings-modal');
                        if (settingsModal && settingsModal.style.display === 'block') {
                            const activeTabBtn = document.querySelector('.settings-nav-btn.active');
                            const activeTab = activeTabBtn ? activeTabBtn.getAttribute('data-tab') : null;
                            if (activeTab === 'members') {
                                loadServerMembersForSettings();
                            } else if (activeTab === 'kick') {
                                loadKickableMembers();
                            } else if (activeTab === 'admins') {
                                loadAdminsManagement();
                            }
                        }

                        // Recolor visible message authors in the current view
                        const authors = document.querySelectorAll('#messages-container .message-author');
                        for (const el of authors) {
                            const uid = el.getAttribute('data-user-id');
                            if (uid) await applyRoleColorToAuthorElement(el, uid);
                        }

                        // Update right members panel immediately
                        await loadServerMembers(sid);
                        // Apply role colors to right panel names as well
                        const panelItems = document.querySelectorAll('#members-list .member-item');
                        for (const item of panelItems) {
                            const uid = item.getAttribute('data-user-id');
                            const nameEl = item.querySelector('.member-name');
                            if (uid && nameEl) {
                                await applyRoleColorToAuthorElement(nameEl, uid);
                            }
                        }

                        // Update channel management button visibility in case current user was promoted/demoted
                        checkChannelManagementPermission(sid);
                    });
                } catch (e) {
                    console.error('Error handling server-member-updated event:', e);
                }
            });
            // Listen for server deletion event
            socket.on('server-deleted', (data) => {
                try {
                    const deletedId = parseFloat(data.serverId);
                    const deletedName = data.serverName || 'Server';
                    // Record the event for DELETE reconciliation
                    lastDeletedServerEvent = { id: deletedId, at: Date.now() };
                    const isLocal = pendingLocalServerDelete.id === deletedId && (Date.now() - pendingLocalServerDelete.at) < 3000;
                    if (isLocal) {
                        // Clear the pending flag and avoid duplicate UI/toast; ensure modals/settings closed
                        pendingLocalServerDelete = { id: null, at: 0 };
                        if (typeof cancelDeleteServerFlow === 'function') cancelDeleteServerFlow();
                        const settingsModal = document.getElementById('server-settings-modal');
                        if (settingsModal) hideServerSettings();
                        return; // UI was already updated locally
                    }
                    // If currently viewing it, redirect to Home/Friends and close settings
                    if (currentServer && parseFloat(currentServer.id) === deletedId) {
                        if (socket && currentChannel && currentChannel.id) {
                            socket.emit('leave-channel', currentChannel.id);
                        }
                        selectHome();
                        const settingsModal = document.getElementById('server-settings-modal');
                        if (settingsModal) hideServerSettings();
                        // Also ensure any custom delete modals are closed
                        if (typeof cancelDeleteServerFlow === 'function') {
                            cancelDeleteServerFlow();
                        }
                    }
                    // Animate and remove the server icon from sidebar
                    const icon = document.querySelector(`.server-icon[data-server-id="${deletedId}"]`);
                    if (icon) {
                        icon.classList.add('pop-out');
                        setTimeout(() => { icon.remove(); }, 240);
                    }
                    // Remove from local list
                    userServers = userServers.filter(s => parseFloat(s.id) !== deletedId);
                    showNotification(`"${deletedName}" was deleted`, 'error');
                } catch (e) {
                    console.error('Error handling server-deleted event:', e);
                }
            });
            // Server metadata/icon updates
            socket.on('server-updated', (data) => {
                try {
                    const sid = parseFloat(data.id);
                    // Update in userServers array
                    userServers = userServers.map(s => parseFloat(s.id) === sid ? { ...s, name: data.name, description: data.description, icon: data.icon } : s);
                    // Update sidebar icon instantly with cache-busting (only for non-data URLs)
                    const iconEl = document.querySelector(`.server-icon[data-server-id="${sid}"]`);
                    if (iconEl) {
                        if (data.icon) {
                            const isData = typeof data.icon === 'string' && data.icon.startsWith('data:image');
                            const url = isData ? data.icon : `${data.icon}${data.icon.includes('?') ? '&' : '?'}v=${Date.now()}`;
                            iconEl.classList.add('has-image');
                            iconEl.style.backgroundImage = `url(${url})`;
                            iconEl.style.backgroundSize = 'cover';
                            iconEl.style.backgroundPosition = 'center';
                            iconEl.style.backgroundRepeat = 'no-repeat';
                            iconEl.textContent = '';
                        } else {
                            iconEl.classList.remove('has-image');
                            iconEl.style.backgroundImage = '';
                            iconEl.textContent = (data.name || 'S').charAt(0).toUpperCase();
                        }
                        iconEl.title = data.name;
                    }
                    // If currently selected server
                    if (currentServer && parseFloat(currentServer.id) === sid) {
                        currentServer.name = data.name;
                        currentServer.description = data.description;
                        currentServer.icon = data.icon || null;
                        // Update header
                        document.getElementById('current-server-name').textContent = data.name;
                        // Update settings preview icon if modal open
                        const settingsIcon = document.getElementById('server-settings-icon');
                        if (settingsIcon) {
                            settingsIcon.dataset.previewDataUrl = '';
                            if (currentServer.icon) {
                                const isData2 = typeof currentServer.icon === 'string' && currentServer.icon.startsWith('data:image');
                                const url = isData2 ? currentServer.icon : `${currentServer.icon}${currentServer.icon.includes('?') ? '&' : '?'}v=${Date.now()}`;
                                settingsIcon.style.backgroundImage = `url(${url})`;
                                settingsIcon.style.backgroundSize = 'cover';
                                settingsIcon.style.backgroundPosition = 'center';
                                settingsIcon.style.backgroundRepeat = 'no-repeat';
                                settingsIcon.style.backgroundColor = 'transparent';
                                settingsIcon.textContent = '';
                            } else {
                                settingsIcon.style.backgroundImage = '';
                                settingsIcon.style.background = 'var(--brand-2)';
                                settingsIcon.textContent = (currentServer.name || 'S').charAt(0).toUpperCase();
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error handling server-updated event:', e);
                }
            });
            // Listen for direct messages
            socket.on('new-direct-message', async (message) => {
                console.log('Received new DM:', message);
                console.log('Current DM user:', currentDMUser);
                console.log('Current view:', currentView);
                
                if (currentView === 'dm' && currentDMUser && 
                    (message.senderId == currentDMUser.id || message.recipientId == currentDMUser.id)) {
                    console.log('Adding DM to UI');
                    await addMessageToUI(message);
                    
                    // Update DM list if sender is not current user
                    if (message.senderId !== parseInt(localStorage.getItem('userId'))) {
                        const sender = { id: message.senderId, username: message.username, avatar: message.avatar || null };
                        if (dmUsers.has(sender.id)) {
                            const prev = dmUsers.get(sender.id);
                            dmUsers.set(sender.id, { ...prev, username: sender.username, avatar: sender.avatar ?? prev.avatar });
                            updateDMList();
                        } else {
                            addToDMList(sender);
                        }
                    }
                    
                    // Update direct messages cache and refresh DM list
                    const otherUserId = message.senderId === parseInt(localStorage.getItem('userId')) ? message.recipientId : message.senderId;
                    let userMessages = directMessages.get(otherUserId) || [];
                    userMessages.push(message);
                    directMessages.set(otherUserId, userMessages);
                    updateDMList();
                } else {
                    console.log('DM not for current conversation - message for:', message.senderId, message.recipientId, 'current user:', currentDMUser?.id);
                    
                    // Still add to cache and update DM list for other conversations
                    const otherUserId = message.senderId === parseInt(localStorage.getItem('userId')) ? message.recipientId : message.senderId;
                    let userMessages = directMessages.get(otherUserId) || [];
                    userMessages.push(message);
                    directMessages.set(otherUserId, userMessages);
                    
                    // Add sender to DM list if not current user
                    if (message.senderId !== parseInt(localStorage.getItem('userId'))) {
                        const sender = { id: message.senderId, username: message.username, avatar: message.avatar || null };
                        if (dmUsers.has(sender.id)) {
                            const prev = dmUsers.get(sender.id);
                            dmUsers.set(sender.id, { ...prev, username: sender.username, avatar: sender.avatar ?? prev.avatar });
                            updateDMList();
                        } else {
                            addToDMList(sender);
                        }
                    }
                }
            });

            // Real-time profile updates (username/avatar/bio)
            socket.on('user-updated', async (data) => {
                try {
                    const { id, username, avatar } = data || {};
                    if (!id) return;
                    const uid = parseInt(id);
                    const isSelf = currentUser && parseInt(currentUser.id) === uid;

                    // Update DM cache and list
                    if (dmUsers && dmUsers.has(uid)) {
                        const existing = dmUsers.get(uid);
                        dmUsers.set(uid, { ...existing, username: username ?? existing.username, avatar: typeof avatar !== 'undefined' ? avatar : existing.avatar });
                        updateDMList();
                    }

                    // If currently in a DM with this user, update header and local object
                    if (currentView === 'dm' && currentDMUser && parseInt(currentDMUser.id) === uid) {
                        currentDMUser.username = username ?? currentDMUser.username;
                        currentDMUser.avatar = typeof avatar !== 'undefined' ? avatar : currentDMUser.avatar;
                        document.getElementById('current-server-name').textContent = `Direct Message with ${currentDMUser.username}`;
                        document.getElementById('current-channel-name').textContent = currentDMUser.username;
                        // Ensure the DM item label updates (covered by updateDMList above as well)
                        updateDMList();
                    }

                    // Do not retroactively update avatars in already-rendered messages to preserve history
                    // Names elsewhere (DM headers, lists) are updated above; existing message bubbles remain unchanged

                    // If we're inside a server view, refresh members panel and settings if needed
                    if (currentServer) {
                        const sid = parseFloat(currentServer.id);
                        await loadServerMembersCache(sid);
                        await loadServerMembers(sid);
                        // If settings modal open on members-related tabs, refresh
                        const settingsModal = document.getElementById('server-settings-modal');
                        if (settingsModal && settingsModal.style.display === 'block') {
                            const activeTabBtn = document.querySelector('.settings-nav-btn.active');
                            const activeTab = activeTabBtn ? activeTabBtn.getAttribute('data-tab') : null;
                            if (activeTab === 'members') {
                                loadServerMembersForSettings();
                            } else if (activeTab === 'admins') {
                                loadAdminsManagement();
                            } else if (activeTab === 'kick') {
                                loadKickableMembers();
                            }
                        }
                    }

                    // If Friends main is visible, refresh relevant tabs
                    const friendsArea = document.getElementById('friends-main-area');
                    if (friendsArea && friendsArea.style.display !== 'none') {
                        // Detect active friends tab
                        const activeFriendsTab = document.querySelector('.friends-tab-main.active');
                        if (activeFriendsTab) {
                            const idAttr = activeFriendsTab.id || '';
                            if (idAttr.includes('current-friends')) {
                                loadCurrentFriends();
                            } else if (idAttr.includes('pending-requests')) {
                                loadPendingRequestsMain();
                            }
                        }
                    }

                    // If this is self, also update bottom-left current user display just in case
                    if (isSelf && currentUser) {
                        if (typeof username === 'string' && username.trim()) currentUser.username = username.trim();
                        currentUser.avatar = typeof avatar !== 'undefined' ? avatar : currentUser.avatar;
                        const userNameEl = document.getElementById('current-user-name');
                        if (userNameEl) userNameEl.textContent = currentUser.username;
                        const userAvatarEl = document.getElementById('current-user-avatar');
                        if (userAvatarEl) {
                            if (currentUser.avatar) {
                                userAvatarEl.style.backgroundImage = `url(${currentUser.avatar})`;
                                userAvatarEl.style.backgroundSize = 'cover';
                                userAvatarEl.style.backgroundPosition = 'center';
                                userAvatarEl.style.backgroundRepeat = 'no-repeat';
                                userAvatarEl.textContent = '';
                            } else {
                                userAvatarEl.style.backgroundImage = '';
                                userAvatarEl.textContent = (currentUser.username || 'A').charAt(0).toUpperCase();
                            }
                        }
                    }
                } catch (e) {
                    console.error('Error handling user-updated event:', e);
                }
            });
        }

        // Update avatars and names in already-rendered messages for a specific user
        function updateMessageAvatarsForUser(userId, newUsername, newAvatar) {
            try {
                const container = document.getElementById('messages-container');
                if (!container) return;
                const authors = container.querySelectorAll('.message-author');
                authors.forEach(authorEl => {
                    const uidAttr = authorEl.getAttribute('data-user-id');
                    if (!uidAttr) return;
                    if (parseInt(uidAttr) === parseInt(userId)) {
                        // Update display name if provided
                        if (typeof newUsername === 'string' && newUsername.trim()) {
                            authorEl.textContent = newUsername;
                        }
                        // Update avatar element (sibling)
                        const parent = authorEl.closest('.message');
                        const avatarEl = parent ? parent.querySelector('.message-avatar') : null;
                        if (avatarEl) {
                            if (newAvatar) {
                                avatarEl.classList.add('has-image');
                                avatarEl.style.backgroundImage = `url(${newAvatar})`;
                                avatarEl.style.backgroundSize = 'cover';
                                avatarEl.style.backgroundPosition = 'center';
                                avatarEl.style.backgroundRepeat = 'no-repeat';
                                avatarEl.textContent = '';
                            } else {
                                avatarEl.classList.remove('has-image');
                                avatarEl.style.backgroundImage = '';
                                // Fallback to gradient + initial using current text
                                const initial = (newUsername || authorEl.textContent || '?').charAt(0).toUpperCase();
                                avatarEl.textContent = initial;
                            }
                        }
                    }
                });
            } catch (err) {
                console.warn('Failed updating message avatars for user:', err);
            }
        }

        // Load user's servers
        async function loadUserServers() {
            try {
                const response = await fetch('/api/servers', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    userServers = data.servers;
                    displayUserServers();
                }
            } catch (error) {
                console.error('Error loading servers:', error);
            }
        }

        // Display servers in the sidebar
        function displayUserServers() {
            const serversContainer = document.getElementById('user-servers');
            serversContainer.innerHTML = '';

            console.log('=== Displaying user servers ===');
            console.log('userServers:', userServers);

            userServers.forEach((server, index) => {
                console.log(`Server ${index}:`, server);
                console.log(`Server ${index} keys:`, Object.keys(server));
                console.log(`Server ${index} id:`, server.id, typeof server.id);
                
                const serverIcon = document.createElement('div');
                serverIcon.className = 'server-icon';
                serverIcon.dataset.serverId = server.id;
                serverIcon.onclick = () => {
                    console.log('Server icon clicked, server object:', server);
                    selectServer(server);
                };
                serverIcon.title = server.name;
                
                // Use server image if available, else first letter
                if (server.icon) {
                    serverIcon.style.backgroundImage = `url(${server.icon})`;
                    serverIcon.style.backgroundSize = 'cover';
                    serverIcon.style.backgroundPosition = 'center';
                    serverIcon.style.backgroundRepeat = 'no-repeat';
                    serverIcon.classList.add('has-image');
                    serverIcon.textContent = '';
                } else {
                    serverIcon.style.backgroundImage = '';
                    serverIcon.classList.remove('has-image');
                    serverIcon.textContent = server.name.charAt(0).toUpperCase();
                }
                
                serversContainer.appendChild(serverIcon);
            });
        }

        // Server selection functions
        function selectHome() {
            currentServer = null;
            currentChannel = null;
            
            // Update UI
            document.querySelector('.server-icon.active')?.classList.remove('active');
            document.querySelector('.server-icon.home').classList.add('active');
            
            document.getElementById('current-server-name').textContent = 'Direct Messages';
            document.getElementById('friends-section').style.display = 'block';
            document.getElementById('server-channels-section').style.display = 'none';
            document.getElementById('invite-btn').style.display = 'none';
            
            // Hide members panel when not in a server
            hideMembersPanel();
            
            // Show friends main area
            showFriendsMain();
        }

        async function selectServer(server) {
            console.log('=== selectServer called ===');
            console.log('Input server object:', server);
            console.log('Input server keys:', Object.keys(server));
            console.log('Input server.id:', server.id, typeof server.id);
            
            currentServer = server;
            console.log('currentServer set to:', currentServer);
            console.log('currentServer.id after assignment:', currentServer.id, typeof currentServer.id);
            
            currentView = 'server';
            
            // Update UI
            document.querySelector('.server-icon.active')?.classList.remove('active');
            document.querySelector(`[data-server-id="${server.id}"]`)?.classList.add('active');
            
            // Hide friends UI and show messages area
            document.getElementById('friends-main-area').style.display = 'none';
            document.getElementById('messages-container').style.display = 'block';
            document.getElementById('friends-section').style.display = 'none';
            document.getElementById('server-channels-section').style.display = 'block';
            document.getElementById('invite-btn').style.display = 'block';
            document.getElementById('message-input-area').style.display = 'block';
            
            // Show members panel for servers (will restore saved state)
            showMembersPanel();
            
            document.getElementById('current-server-name').textContent = server.name;
            
            console.log('About to load channels and members...');
            console.log('currentServer before loading:', currentServer);
            
            // Reset cache if switching servers; warm cache for this server
            currentServerMembersMap = new Map();
            currentServerMembersCacheServerId = null;
            await Promise.all([
                loadServerMembersCache(server.id),
                loadServerRolesCache(server.id)
            ]);

            // Load server channels and members
            await loadServerChannels(server.id);
            await loadServerMembers(server.id);
            
            console.log('currentServer after loading channels/members:', currentServer);
            
            // Check if user has permission to manage channels
            checkChannelManagementPermission(server.id);

            // Warm member cache and recolor authors
            await recolorAllVisibleAuthors();
        }

        // Load channels for a server
        async function loadServerChannels(serverId) {
            console.log('Loading channels for server:', serverId);
            try {
                const response = await fetch(`/api/servers/${serverId}/channels`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('Received channels:', data);
                    displayChannels(data.channels);
                    
                    // Auto-select first channel
                    if (data.channels.length > 0) {
                        console.log('Auto-selecting first channel:', data.channels[0]);
                        await selectChannel(data.channels[0]);
                    }
                } else {
                    console.error('Failed to load channels:', response.status, await response.text());
                }
            } catch (error) {
                console.error('Error loading channels:', error);
            }
        }

        // Display channels
        function displayChannels(channels) {
            console.log('Displaying channels:', channels);
            const textChannelsList = document.getElementById('text-channels-list');
            textChannelsList.innerHTML = '';

            const textChannels = channels.filter(ch => ch.type === 'text');
            
            textChannels.forEach(channel => {
                const channelItem = document.createElement('li');
                channelItem.className = 'channel-item';
                channelItem.dataset.channelId = channel.id;
                channelItem.onclick = () => selectChannel(channel);
                
                channelItem.innerHTML = `
                    <span class="channel-icon">#</span>
                    ${channel.name}
                `;
                
                textChannelsList.appendChild(channelItem);
            });
        }

        // Select a channel
        async function selectChannel(channel) {
            console.log('Selecting channel:', channel);
            currentChannel = channel;
            currentView = 'server';
            
            // Update UI - find the correct channel item by data attribute
            document.querySelectorAll('.channel-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.channelId == channel.id) {
                    item.classList.add('active');
                }
            });
            
            document.getElementById('header-icon').textContent = '#';
            document.getElementById('current-channel-name').textContent = channel.name;
            document.getElementById('current-channel-info').textContent = `${currentServer.name} • ${channel.name}`;
            document.getElementById('message-input-area').style.display = 'block';
            
            // Join channel room
            if (socket) {
                socket.emit('join-channel', channel.id);
            }
            
            // Load messages
            await loadMessages(channel.id);
        }

        // Load messages for a channel
        async function loadMessages(channelId) {
            console.log('Loading messages for channel:', channelId);
            try {
                const response = await fetch(`/api/messages/channel/${channelId}`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                console.log('Load messages response:', response.status);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Received messages:', data);
                    await displayMessages(data.messages);
                } else {
                    const error = await response.text();
                    console.error('Failed to load messages:', response.status, error);
                }
            } catch (error) {
                console.error('Error loading messages:', error);
            }
        }

        // Display messages
        async function displayMessages(messages) {
            console.log('Displaying messages:', messages);
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = '';

            if (messages.length === 0) {
                console.log('No messages, showing welcome');
                
                if (currentView === 'dm' && currentDMUser) {
                    // Show DM welcome message
                    const welcomeDiv = document.createElement('div');
                    welcomeDiv.className = 'welcome-message dm-welcome';
                    welcomeDiv.innerHTML = `
                        <h3>💬 Direct Message with ${currentDMUser.username}</h3>
                        <p>This is the beginning of your direct message conversation with ${currentDMUser.username}. Say hello!</p>
                    `;
                    messagesContainer.appendChild(welcomeDiv);
                } else {
                    // Show channel welcome message when no messages
                    const welcomeDiv = document.createElement('div');
                    welcomeDiv.className = 'welcome-message';
                    welcomeDiv.innerHTML = `
                        <h3>Welcome to #${currentChannel ? currentChannel.name : 'general'}!</h3>
                        <p>This is the beginning of the #${currentChannel ? currentChannel.name : 'general'} channel. Start chatting to see your messages here!</p>
                    `;
                    messagesContainer.appendChild(welcomeDiv);
                }
            } else {
                console.log('Found messages, adding to UI:', messages.length);
                for (const message of messages) {
                    await addMessageToUI(message);
                }
            }
            // After bulk render, ensure member cache is ready then apply colors to all authors if in a server
            if (currentServer) {
                // Warm cache if empty or mismatched server
                if (!currentServerMembersMap || currentServerMembersMap.size === 0 || currentServerMembersCacheServerId !== parseFloat(currentServer.id)) {
                    await loadServerMembersCache(currentServer.id);
                }
                const authors = document.querySelectorAll('#messages-container .message-author');
                for (const el of authors) {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                }
            }
            scrollToBottom();
        }

        // Add message to UI
        async function addMessageToUI(message) {
            console.log('Adding message to UI:', message);
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message';
            messageDiv.dataset.messageId = message.id;
            messageDiv.dataset.channelId = message.channelId || '';
            messageDiv.dataset.isDm = currentView === 'dm' ? 'true' : 'false';
            
            // Handle both DM messages (createdAt) and channel messages (timestamp)
            const messageTime = message.createdAt || message.timestamp;
            const messageText = message.text || message.content || '';
            
            if (!messageTime) {
                console.error('No timestamp found in message:', message);
                return;
            }
            
            const timeAgo = getTimeAgo(new Date(messageTime));
            const actualTime = new Date(messageTime).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            // Pre-compute inline color from caches (non-blocking)
            let authorIdForColor = message.userId || message.senderId || '';
            let inlineAuthorColor = '#dcddde';
            try { inlineAuthorColor = getRoleColorFromCaches(authorIdForColor); } catch {}

            const authorInitial = message.username ? message.username.charAt(0).toUpperCase() : '?';
            // Use only the avatar captured at send-time; do not fall back to current profile avatar for historical messages
            const avatarUrl = message.avatar || null;
            const authorAvatarStyle = avatarUrl ? `style="background-image:url(${avatarUrl}); background-size:cover; background-position:center; background-repeat:no-repeat;"` : '';
            const authorAvatarClass = avatarUrl ? 'message-avatar has-image' : 'message-avatar';
            const editableByCurrent = (currentUser && (message.userId === currentUser.id || message.senderId === currentUser.id)) && !message.deleted;
            const deletedClass = message.deleted ? 'deleted' : '';
            const editedBadge = message.edited ? `<span class="message-edited-indicator" title="Edited">(edited)</span>` : '';
            messageDiv.innerHTML = `
                <div class="${authorAvatarClass}" ${authorAvatarStyle}>${avatarUrl ? '' : authorInitial}</div>
                <div class="message-content ${deletedClass}">
                    <div class="message-header" style="display:flex; align-items:baseline; gap:6px;">
                        <span class="message-author" data-user-id="${message.userId || message.senderId || ''}" style="color: ${inlineAuthorColor}">${message.username}</span>
                        <span class="message-timestamp" style="font-size:12px; color:#72767d;">${timeAgo} at ${actualTime} ${editedBadge}</span>
                        <div class="message-header-spacer" style="flex:1 1 auto;"></div>
                        ${editableByCurrent ? `<div class="message-actions" style="display:none; position:relative;">
                            <button class="msg-btn more" title="More" onclick="toggleMessageMenu(event, '${message.id}')" style="background:transparent; border:none; color:#b9bbbe; cursor:pointer; padding:2px 6px; font-size:18px; line-height:1; transition:color .15s ease, transform .15s ease;">⋯</button>
                            <div class="message-menu" data-open="false" style="display:none; position:absolute; right:0; top:100%; background:rgba(47,49,54,.96); border:1px solid #202225; border-radius:6px; padding:4px 0; min-width:150px; z-index:60; box-shadow:0 6px 18px rgba(0,0,0,0.5);">
                                <button class="menu-item" data-action="edit" onclick="startEditMessage(event, '${message.id}')" style="display:block; width:100%; text-align:left; border:none; color:#dcddde; padding:8px 14px; cursor:pointer; font-size:13px;">Edit</button>
                                <button class="menu-item menu-delete" data-action="delete" onclick="deleteMessage(event, '${message.id}')" style="display:block; width:100%; text-align:left; border:none; color:#ed4245; padding:8px 14px; cursor:pointer; font-size:13px;">Delete</button>
                            </div>
                        </div>` : ''}
                    </div>
                    <div class="message-text" data-original="${escapeHtml(messageText)}">${message.deleted ? '<i style="color:#8e9297;">This message was deleted</i>' : linkifyMessageText(messageText) + (message.edited ? ' <span class="message-edited-indicator" title="Edited">(edited)</span>' : '')}</div>
                    ${message.attachments && message.attachments.length > 0 ?
                        message.attachments.map(att =>
                            att.type === 'image' ?
                                `<div class="message-attachment"><img src="${att.url}" alt="${att.filename}" class="message-image" onclick="openImageModal('${att.url}')"></div>` :
                                `<div class="message-attachment">📎 ${att.filename}</div>`
                        ).join('') : ''}
                </div>
            `;
            if (editableByCurrent) {
                messageDiv.addEventListener('mouseenter', () => {
                    const actions = messageDiv.querySelector('.message-actions');
                    if (actions) actions.style.display = 'block';
                });
                messageDiv.addEventListener('mouseleave', () => {
                    const actions = messageDiv.querySelector('.message-actions');
                    if (actions) {
                        const menu = actions.querySelector('.message-menu');
                        if (!menu || menu.dataset.open !== 'true') actions.style.display = 'none';
                    }
                });
            }
            
            messagesContainer.appendChild(messageDiv);
            // Apply color to this author
            const authorEl = messageDiv.querySelector('.message-author');
            const authorUserId = message.userId || message.senderId;
            if (authorEl && authorUserId && currentServer) {
                // Ensure we have the latest member cache and it matches this server before coloring
                if (!currentServerMembersMap || currentServerMembersMap.size === 0 || currentServerMembersCacheServerId !== parseFloat(currentServer.id)) {
                    await loadServerMembersCache(currentServer.id);
                }
                await applyRoleColorToAuthorElement(authorEl, authorUserId);
            }
            scrollToBottom();
            console.log('Message added to UI successfully');
        }

        // Send message
        async function sendMessage() {
            const messageInput = document.getElementById('message-input');
            const imageInput = document.getElementById('image-input');
            const text = messageInput.value.trim();
            const files = imageInput.files;
            
            console.log('Sending message:', text, 'Current view:', currentView, 'Current channel:', currentChannel);
            
            if (!text && files.length === 0) return;
            
            try {
                const formData = new FormData();
                formData.append('text', text);
                
                // Check if we're in DM or channel mode
                if (currentView === 'dm' && currentDMUser) {
                    formData.append('recipientId', currentDMUser.id);
                    formData.append('type', 'dm');
                    console.log('Sending DM to:', currentDMUser);
                } else if (currentChannel) {
                    formData.append('channelId', currentChannel.id);
                    formData.append('type', 'channel');
                    console.log('Sending channel message to:', currentChannel);
                } else {
                    console.log('No valid target for message');
                    return; // No valid target
                }
                
                // Add selected images
                for (let i = 0; i < files.length; i++) {
                    formData.append('images', files[i]);
                }
                
                const response = await fetch('/api/messages', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                        // Don't set Content-Type header - let browser set it for FormData
                    },
                    body: formData
                });

                console.log('Message send response:', response.status);
                if (response.ok) {
                    const result = await response.json();
                    console.log('Message sent successfully:', result);
                    messageInput.value = '';
                    imageInput.value = ''; // Clear selected images
                    clearImagePreviews(); // Clear preview area
                } else {
                    const error = await response.text();
                    console.error('Failed to send message:', response.status, error);
                }
            } catch (error) {
                console.error('Error sending message:', error);
            }
        }

        // ===== Message Edit/Delete Frontend Logic =====
        let editingMessageId = null;
        function startEditMessage(ev, messageId) {
            ev.stopPropagation();
            if (editingMessageId) finishEditMessage(false);
            const msgEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (!msgEl) return;
            // Close the 3-dots menu immediately so user has clean edit space
            const menu = msgEl.querySelector('.message-menu');
            const actionsWrap = msgEl.querySelector('.message-actions');
            if (menu) { menu.dataset.open = 'false'; menu.classList.remove('open'); menu.style.display = 'none'; }
            if (actionsWrap) { actionsWrap.style.display = 'none'; }
            const textEl = msgEl.querySelector('.message-text');
            if (!textEl || textEl.classList.contains('editing')) return;
            if (textEl.closest('.message-content')?.classList.contains('deleted')) return;
            editingMessageId = messageId;
            const original = textEl.getAttribute('data-original') || textEl.textContent || '';
            textEl.dataset.prevHtml = textEl.innerHTML;
            textEl.classList.add('editing');
            textEl.innerHTML = `<textarea class="message-edit-textarea" style="width:100%; background:#2f3136; color:#dcddde; border:1px solid #4f545c; border-radius:4px; padding:6px; font:inherit; resize:vertical; min-height:60px;">${escapeHtml(original)}</textarea>
            <div class="edit-actions" style="margin-top:4px; display:flex; gap:8px;">
              <button class="btn btn-sm" onclick="confirmEditMessage('${messageId}')">Save</button>
              <button class="btn btn-sm btn-secondary" onclick="finishEditMessage(false)">Cancel</button>
              <span style="font-size:11px; color:#8e9297; margin-left:auto;">Press Enter to save, Esc to cancel</span>
            </div>`;
            const ta = textEl.querySelector('textarea');
            ta.focus();
            ta.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); confirmEditMessage(messageId); }
                else if (e.key === 'Escape') { e.preventDefault(); finishEditMessage(false); }
            });
        }
        async function confirmEditMessage(messageId) {
            const msgEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (!msgEl) return finishEditMessage(false);
            const textEl = msgEl.querySelector('.message-text');
            const ta = textEl.querySelector('textarea');
            if (!ta) return finishEditMessage(false);
            const newContent = ta.value.trim();
            if (!newContent) { finishEditMessage(false); return; }
            const isDm = msgEl.dataset.isDm === 'true';
            try {
                // Optimistic immediate update & local event
                textEl.classList.remove('editing');
                textEl.setAttribute('data-original', newContent);
                textEl.innerHTML = linkifyMessageText(newContent) + ' <span class="message-edited-indicator" title="Edited">(edited)</span>';
                // Fire a local synthetic event so other code relying on socket path stays consistent in dev without server round-trip delay
                setTimeout(()=>{
                    const evtName = isDm ? 'dm-message-edited' : 'message-edited';
                    if (socket) socket.emit && socket.emit('__local_echo__', { type: evtName, id: messageId });
                },0);
                const resp = await fetch(`/api/messages/${isDm ? 'dm' : 'channel'}/${messageId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${localStorage.getItem('token')}` },
                    body: JSON.stringify({ content: newContent })
                });
                const data = await resp.json().catch(()=>({}));
                if (!resp.ok) { showNotification(data.error || 'Failed to edit message', 'error'); finishEditMessage(false); return; }
            } catch (e) { console.error('Edit message failed', e); showNotification('Failed to edit message', 'error'); }
            finally { editingMessageId = null; }
        }
        function finishEditMessage(apply) {
            if (!editingMessageId) return;
            const msgEl = document.querySelector(`.message[data-message-id="${editingMessageId}"]`);
            if (!msgEl) { editingMessageId = null; return; }
            const textEl = msgEl.querySelector('.message-text');
            if (!textEl) { editingMessageId = null; return; }
            if (!apply) {
                const prev = textEl.dataset.prevHtml;
                if (prev) textEl.innerHTML = prev;
            }
            textEl.classList.remove('editing');
            delete textEl.dataset.prevHtml;
            editingMessageId = null;
        }
        const deleteConfirmState = new Map(); // messageId -> timestamp of first click
        async function deleteMessage(ev, messageId) {
            ev.stopPropagation();
            const msgEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (!msgEl) return;
            const menu = msgEl.querySelector('.message-menu');
            const btn = ev.currentTarget; // the delete button
            const now = Date.now();
            const first = deleteConfirmState.get(messageId);
            if (!first || (now - first) > 4000) { // first click or expired
                deleteConfirmState.set(messageId, now);
                btn.textContent = 'Are you sure?';
                btn.classList.add('confirming');
                // auto revert after timeout
                setTimeout(()=>{
                    if (deleteConfirmState.get(messageId) === now) {
                        deleteConfirmState.delete(messageId);
                        if (btn.isConnected) { btn.textContent = 'Delete'; btn.classList.remove('confirming'); }
                    }
                }, 4000);
                return;
            }
            // second click: proceed
            deleteConfirmState.delete(messageId);
            btn.disabled = true;
            btn.style.opacity = '.6';
            const isDm = msgEl.dataset.isDm === 'true';
            // Optimistic UI change immediately
            markMessageDeleted(messageId);
            setTimeout(()=>{
                if (socket) socket.emit && socket.emit('__local_echo__', { type: isDm ? 'dm-message-deleted' : 'message-deleted', id: messageId });
            },0);
            try {
                const resp = await fetch(`/api/messages/${isDm ? 'dm' : 'channel'}/${messageId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                if (!resp.ok) {
                    showNotification('Delete failed (reverting)', 'error');
                    // Could optionally re-fetch or revert; simpler: fetch latest for message list
                }
            } catch (e) { console.error('Delete failed', e); showNotification('Failed to delete message', 'error'); }
            finally {
                if (menu) { menu.dataset.open = 'false'; menu.classList.remove('open'); menu.style.display='none'; }
                const actions = msgEl.querySelector('.message-actions');
                if (actions) actions.style.display='none';
            }
        }
        function markMessageDeleted(messageId) {
            const msgEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (!msgEl) return;
            const content = msgEl.querySelector('.message-content');
            const textEl = msgEl.querySelector('.message-text');
            if (content) content.classList.add('deleted');
            if (textEl) textEl.innerHTML = '<i style="color:#8e9297;">This message was deleted</i>';
            const actions = msgEl.querySelector('.message-actions');
            if (actions) actions.remove();
        }

        // ===== 3-dots menu helpers =====
        function closeAllMessageMenus(exceptId=null){
            document.querySelectorAll('.message-menu[data-open="true"]').forEach(menu => {
                const parentMsg = menu.closest('.message');
                if (exceptId && parentMsg && parentMsg.dataset.messageId === exceptId) return;
                menu.dataset.open = 'false';
                menu.style.display = 'none';
                const actions = menu.closest('.message-actions');
                if (actions) actions.style.display = 'none';
            });
        }
        function toggleMessageMenu(ev, messageId){
            ev.stopPropagation();
            const msgEl = document.querySelector(`.message[data-message-id="${messageId}"]`);
            if (!msgEl) return;
            const actions = msgEl.querySelector('.message-actions');
            const menu = msgEl.querySelector('.message-menu');
            if (!menu) return;
            const isOpen = menu.dataset.open === 'true';
            if (isOpen){
                menu.dataset.open = 'false';
                menu.classList.remove('open');
                menu.style.display = 'none';
                actions.style.display = 'block';
            } else {
                closeAllMessageMenus(messageId);
                actions.style.display = 'block';
                menu.dataset.open = 'true';
                menu.style.display = 'block';
                requestAnimationFrame(()=> menu.classList.add('open'));
            }
        }
        document.addEventListener('click', (e)=>{
            if (e.target.closest('.message-actions')) return; // inside
            closeAllMessageMenus();
        });

        function attachEditDeleteSocketListeners(){
            if (window.__editDeleteSocketsAttached) return;
            if (!socket) return; // wait until initialized
            window.__editDeleteSocketsAttached = true;
            console.log('[Socket] Attaching edit/delete listeners');
            socket.on('message-edited', (data) => {
                const msgEl = document.querySelector(`.message[data-message-id="${data.id}"]`);
                if (msgEl) {
                    const textEl = msgEl.querySelector('.message-text');
                    if (textEl && !msgEl.classList.contains('editing')) {
                        textEl.setAttribute('data-original', data.content);
                        textEl.innerHTML = linkifyMessageText(data.content) + ' <span class="message-edited-indicator" title="Edited">(edited)</span>';
                    }
                }
            });
            socket.on('message-deleted', (data) => { markMessageDeleted(data.id); });
            socket.on('dm-message-edited', (data) => {
                const msgEl = document.querySelector(`.message[data-message-id="${data.id}"]`);
                if (msgEl) {
                    const textEl = msgEl.querySelector('.message-text');
                    if (textEl && !msgEl.classList.contains('editing')) {
                        textEl.setAttribute('data-original', data.text);
                        textEl.innerHTML = linkifyMessageText(data.text) + ' <span class="message-edited-indicator" title="Edited">(edited)</span>';
                    }
                }
            });
            socket.on('dm-message-deleted', (data) => { markMessageDeleted(data.id); });
        }

        // Handle image selection
        function handleImageSelection(event) {
            const files = event.target.files;
            const previewArea = document.getElementById('image-preview-area');
            const previewContainer = document.getElementById('image-preview-container');
            
            if (files.length > 0) {
                previewArea.style.display = 'block';
                previewContainer.innerHTML = '';
                
                Array.from(files).forEach((file, index) => {
                    if (file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            const previewDiv = document.createElement('div');
                            previewDiv.className = 'image-preview';
                            previewDiv.innerHTML = `
                                <img src="${e.target.result}" alt="${file.name}">
                                <button class="remove-image" onclick="removeImagePreview(${index})">×</button>
                            `;
                            previewContainer.appendChild(previewDiv);
                        };
                        reader.readAsDataURL(file);
                    }
                });
            } else {
                previewArea.style.display = 'none';
            }
        }

        // Remove image preview
        function removeImagePreview(index) {
            const imageInput = document.getElementById('image-input');
            const files = Array.from(imageInput.files);
            
            // Create new FileList without the removed file
            const dt = new DataTransfer();
            files.forEach((file, i) => {
                if (i !== index) {
                    dt.items.add(file);
                }
            });
            
            imageInput.files = dt.files;
            handleImageSelection({ target: imageInput });
        }

        // Clear image previews
        function clearImagePreviews() {
            const previewArea = document.getElementById('image-preview-area');
            const previewContainer = document.getElementById('image-preview-container');
            
            previewArea.style.display = 'none';
            previewContainer.innerHTML = '';
        }

        // Image modal functions
        function openImageModal(imageSrc) {
            const modal = document.getElementById('image-modal');
            const modalImage = document.getElementById('modal-image');
            
            modalImage.src = imageSrc;
            modal.style.display = 'block';
        }

        function closeImageModal() {
            document.getElementById('image-modal').style.display = 'none';
        }

        // Server management functions
        // Unified Server Modal Functions
        function showServerModal(tab = 'create') {
            document.getElementById('server-modal').style.display = 'block';
            switchServerTab(tab);
        }

        function hideServerModal() {
            document.getElementById('server-modal').style.display = 'none';
            document.getElementById('create-server-form').reset();
            document.getElementById('join-server-form').reset();
        }

        function switchServerTab(tab) {
            // Remove active class from all tabs
            document.querySelectorAll('.server-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.server-tab-content').forEach(content => content.classList.remove('active'));
            
            // Activate selected tab
            document.getElementById(`${tab}-tab-btn`).classList.add('active');
            document.getElementById(`${tab}-server-tab`).classList.add('active');
            
            // Update modal title
            const title = tab === 'create' ? 'Create Your Server' : 'Join a Server';
            document.getElementById('server-modal-title').textContent = title;
        }

        async function createServer(event) {
            event.preventDefault();
            
            const name = document.getElementById('server-name').value.trim();
            const description = document.getElementById('server-description').value.trim();
            
            try {
                const response = await fetch('/api/servers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ name, description })
                });

                if (response.ok) {
                    hideServerModal();
                    await loadUserServers(); // Reload servers
                    
                    const data = await response.json();
                    selectServer(data.server); // Auto-select new server
                }
            } catch (error) {
                console.error('Error creating server:', error);
            }
        }

        async function joinServer(event) {
            event.preventDefault();
            
            let inviteInput = document.getElementById('invite-code').value.trim();
            
            // Extract invite code from URL if it's a full invite link
            let inviteCode = inviteInput;
            if (inviteInput.includes('/invite/')) {
                // Extract code from URL like "http://localhost:3000/invite/ABC123"
                const matches = inviteInput.match(/\/invite\/([A-Za-z0-9]+)/);
                if (matches && matches[1]) {
                    inviteCode = matches[1];
                }
            }
            
            if (!inviteCode) {
                alert('Please enter a valid invite code or link');
                return;
            }
            
            try {
                const response = await fetch('/api/servers/join', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ inviteCode })
                });

                if (response.ok) {
                    const result = await response.json();
                    hideServerModal();
                    await loadUserServers(); // Reload servers
                    showNotification(`Successfully joined "${result.serverName}"!`, 'success');
                } else {
                    const error = await response.json();
                    alert(error.message || 'Failed to join server');
                }
            } catch (error) {
                console.error('Error joining server:', error);
                alert('Failed to join server. Please try again.');
            }
        }

        // Show welcome message
        function showWelcomeMessage() {
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = `
                <div class="welcome-message">
                    <h3>🎉 Welcome to Enyalis!</h3>
                    <p>Create a server or join one with an invite code to start chatting.</p>
                    <br>
                    <button class="btn btn-primary" onclick="showServerModal('create')">Create Server</button>
                    <button class="btn btn-secondary" onclick="showServerModal('join')" style="margin-left: 12px;">Join Server</button>
                </div>
            `;
        }

        function showFriends() {
            document.querySelectorAll('#friends-section .channel-item').forEach(item => item.classList.remove('active'));
            event.target.closest('.channel-item').classList.add('active');
            
            document.getElementById('header-icon').textContent = '👥';
            document.getElementById('current-channel-name').textContent = 'Friends';
            document.getElementById('current-channel-info').textContent = `${friends.length} friends`;
            
            displayFriendsList();
        }

        function showFriendRequests() {
            document.querySelectorAll('#friends-section .channel-item').forEach(item => item.classList.remove('active'));
            event.target.closest('.channel-item').classList.add('active');
            
            document.getElementById('header-icon').textContent = '📨';
            document.getElementById('current-channel-name').textContent = 'Friend Requests';
            document.getElementById('current-channel-info').textContent = `${friendRequests.incoming.length} pending`;
            
            displayFriendRequests();
        }

        function showAddFriend() {
            document.getElementById('add-friend-modal').style.display = 'block';
        }

        function hideAddFriendModal() {
            document.getElementById('add-friend-modal').style.display = 'none';
            document.getElementById('add-friend-form').reset();
        }

        // Load friends
        async function loadFriends() {
            try {
                const response = await fetch('/api/friends', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    friends = data.friends;
                }
            } catch (error) {
                console.error('Error loading friends:', error);
            }
        }

        // Load friend requests
        async function loadFriendRequests() {
            try {
                const response = await fetch('/api/friends/requests', {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    friendRequests = data;
                    updateFriendRequestsBadge();
                }
            } catch (error) {
                console.error('Error loading friend requests:', error);
            }
        }

        // Update friend requests badge
        function updateFriendRequestsBadge() {
            const badge = document.getElementById('friend-requests-badge');
            if (!badge) {
                console.log('Friend requests badge element not found - skipping badge update');
                return;
            }
            
            if (friendRequests.incoming.length > 0) {
                badge.textContent = friendRequests.incoming.length;
                badge.style.display = 'inline';
            } else {
                badge.style.display = 'none';
            }
        }

        // Send friend request
        async function sendFriendRequest(event) {
            event.preventDefault();
            
            const identifier = document.getElementById('friend-identifier').value.trim();
            
            try {
                const body = identifier.includes('@') ? 
                    { email: identifier } : 
                    { username: identifier };
                
                const response = await fetch('/api/friends/request', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(body)
                });

                const data = await response.json();

                if (response.ok) {
                    hideAddFriendModal();
                    alert('Friend request sent successfully!');
                    loadFriendRequests();
                } else {
                    alert(data.error || 'Failed to send friend request');
                }
            } catch (error) {
                console.error('Error sending friend request:', error);
                alert('Failed to send friend request');
            }
        }

        // Accept friend request
        async function acceptFriendRequest(requestId) {
            try {
                const response = await fetch(`/api/friends/accept/${requestId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    await loadFriends();
                    await loadFriendRequests();
                    showFriends();
                }
            } catch (error) {
                console.error('Error accepting friend request:', error);
            }
        }

        // Decline friend request
        async function declineFriendRequest(requestId) {
            try {
                const response = await fetch(`/api/friends/decline/${requestId}`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    await loadFriendRequests();
                    showFriendRequests();
                }
            } catch (error) {
                console.error('Error declining friend request:', error);
            }
        }

        // Display friends list
        function displayFriendsList() {
            const messagesContainer = document.getElementById('messages-container');
            
            if (friends.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="welcome-message">
                        <h3>👥 No Friends Yet</h3>
                        <p>Add friends to start direct messaging and see who's online!</p>
                        <br>
                        <button class="btn btn-primary" onclick="showAddFriend()">Add Friend</button>
                    </div>
                `;
                return;
            }
            
            messagesContainer.innerHTML = `
                <div style="padding: 20px;">
                    <div style="display: grid; gap: 12px;">
                        ${friends.map(friend => `
                            <div style="display: flex; align-items: center; padding: 12px; background: #2f3136; border-radius: 8px;">
                                <div class="message-avatar" style="margin-right: 12px; width: 32px; height: 32px; font-size: 14px;">
                                    ${friend.username.charAt(0).toUpperCase()}
                                </div>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: white;">${friend.username}</div>
                                    <div style="font-size: 12px; color: #8e9297;">Friends since ${new Date(friend.friendsSince).toLocaleDateString()}</div>
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;">Message</button>
                                    <button class="btn btn-secondary" onclick="removeFriend(${friend.id})" style="padding: 6px 12px; font-size: 12px; background: #f04747;">Remove</button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // Display friend requests
        function displayFriendRequests() {
            const messagesContainer = document.getElementById('messages-container');
            
            if (friendRequests.incoming.length === 0 && friendRequests.outgoing.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="welcome-message">
                        <h3>📨 No Friend Requests</h3>
                        <p>When someone sends you a friend request, it will appear here.</p>
                    </div>
                `;
                return;
            }
            
            let html = '<div style="padding: 20px;">';
            
            if (friendRequests.incoming.length > 0) {
                html += `
                    <h4 style="color: white; margin-bottom: 12px;">Incoming Requests</h4>
                    <div style="display: grid; gap: 12px; margin-bottom: 24px;">
                        ${friendRequests.incoming.map(request => `
                            <div style="display: flex; align-items: center; padding: 12px; background: #2f3136; border-radius: 8px;">
                                <div class="message-avatar" style="margin-right: 12px; width: 32px; height: 32px; font-size: 14px;">
                                    ${request.senderUsername.charAt(0).toUpperCase()}
                                </div>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: white;">${request.senderUsername}</div>
                                    <div style="font-size: 12px; color: #8e9297;">Sent ${new Date(request.createdAt).toLocaleDateString()}</div>
                                </div>
                                <div style="display: flex; gap: 8px;">
                                    <button class="btn btn-primary" onclick="acceptFriendRequest('${request.id}')" style="padding: 6px 12px; font-size: 12px;">Accept</button>
                                    <button class="btn btn-secondary" onclick="declineFriendRequest('${request.id}')" style="padding: 6px 12px; font-size: 12px;">Decline</button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            if (friendRequests.outgoing.length > 0) {
                html += `
                    <h4 style="color: white; margin-bottom: 12px;">Outgoing Requests</h4>
                    <div style="display: grid; gap: 12px;">
                        ${friendRequests.outgoing.map(request => `
                            <div style="display: flex; align-items: center; padding: 12px; background: #2f3136; border-radius: 8px;">
                                <div class="message-avatar" style="margin-right: 12px; width: 32px; height: 32px; font-size: 14px;">
                                    ${request.receiverUsername.charAt(0).toUpperCase()}
                                </div>
                                <div style="flex: 1;">
                                    <div style="font-weight: bold; color: white;">${request.receiverUsername}</div>
                                    <div style="font-size: 12px; color: #8e9297;">Pending since ${new Date(request.createdAt).toLocaleDateString()}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            html += '</div>';
            messagesContainer.innerHTML = html;
        }

        // Remove friend
        async function removeFriend(friendId) {
            if (!confirm('Are you sure you want to remove this friend?')) return;
            
            try {
                const response = await fetch(`/api/friends/${friendId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    await loadFriends();
                    displayFriendsList();
                }
            } catch (error) {
                console.error('Error removing friend:', error);
            }
        }

        // Server invite functions
        function showInviteModal() {
            if (!currentServer) return;
            
            document.getElementById('invite-server-name').textContent = currentServer.name;
            document.getElementById('invite-link').value = `${window.location.origin}/invite/${currentServer.inviteCode}`;
            document.getElementById('server-invite-modal').style.display = 'block';
        }

        function hideInviteModal() {
            document.getElementById('server-invite-modal').style.display = 'none';
        }

        function copyInviteLink() {
            const inviteLink = document.getElementById('invite-link');
            const copyBtn = document.getElementById('copy-invite-btn');
            
            if (!inviteLink || !inviteLink.value) {
                showNotification('No invite link to copy', 'error');
                return;
            }

            // Try modern clipboard API first
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(inviteLink.value).then(() => {
                    // Visual feedback
                    const originalText = copyBtn.textContent;
                    const originalBackground = copyBtn.style.background;
                    
                    copyBtn.textContent = 'Copied!';
                    copyBtn.style.background = '#43b581';
                    
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                        copyBtn.style.background = originalBackground;
                    }, 2000);
                    
                    showNotification('Invite link copied to clipboard!', 'success');
                }).catch((err) => {
                    console.error('Failed to copy using clipboard API:', err);
                    fallbackCopy();
                });
            } else {
                fallbackCopy();
            }
            
            function fallbackCopy() {
                try {
                    // Fallback for older browsers
                    inviteLink.focus();
                    inviteLink.select();
                    inviteLink.setSelectionRange(0, 99999);
                    
                    const successful = document.execCommand('copy');
                    if (successful) {
                        const originalText = copyBtn.textContent;
                        const originalBackground = copyBtn.style.background;
                        
                        copyBtn.textContent = 'Copied!';
                        copyBtn.style.background = '#43b581';
                        
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                            copyBtn.style.background = originalBackground;
                        }, 2000);
                        
                        showNotification('Invite link copied to clipboard!', 'success');
                    } else {
                        showNotification('Failed to copy invite link', 'error');
                    }
                } catch (err) {
                    console.error('Failed to copy using fallback:', err);
                    showNotification('Copy failed - please manually select and copy the link', 'error');
                }
            }
        }

        function showServerMenu() {
            // Only show server settings if user is the server owner and we're in a server
            if (currentServer && currentUser && currentServer.ownerId === currentUser.id) {
                showServerSettings();
            } else if (currentServer) {
                // Non-owners just see server info
                console.log('Server info for:', currentServer.name);
                showNotification('Only server owners can access server settings', 'info');
            } else {
                console.log('No current server');
            }
        }

        // Server preview modal logic
        let pendingInviteCode = null;

        async function showServerPreview(inviteCode) {
            try {
                pendingInviteCode = normalizeInviteCode(inviteCode);
                const token = localStorage.getItem('token');
                const resp = await fetch(`/api/servers/preview/${pendingInviteCode}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                if (!resp.ok) {
                    const data = await resp.json().catch(() => ({}));
                    showNotification(data.error || 'Invalid invite link', 'error');
                    return;
                }
                const data = await resp.json();
                const server = data.server;
                const stats = data.stats || {};

                // Populate modal
                const iconEl = document.getElementById('preview-server-icon');
                iconEl.textContent = '';
                if (server.icon) {
                    iconEl.style.background = 'none';
                    iconEl.style.backgroundImage = `url(${server.icon})`;
                    iconEl.style.backgroundSize = 'cover';
                    iconEl.style.backgroundPosition = 'center';
                } else {
                    iconEl.style.background = 'var(--brand-2)';
                    iconEl.style.backgroundImage = '';
                    iconEl.textContent = server.name ? server.name.charAt(0).toUpperCase() : '?';
                }
                document.getElementById('preview-server-name').textContent = server.name;
                document.getElementById('preview-server-description').textContent = server.description || 'No description provided.';
                document.getElementById('preview-member-count').textContent = `${stats.memberCount || 0} members`;

                document.getElementById('server-preview-modal').style.display = 'block';
            } catch (err) {
                console.error('Failed to load server preview:', err);
                showNotification('Failed to load invite preview', 'error');
            }
        }

        function hideServerPreviewModal() {
            document.getElementById('server-preview-modal').style.display = 'none';
            pendingInviteCode = null;
        }

        function normalizeInviteCode(input) {
            // Extract invite code from full URL `/invite/ABC123` or query value
            try {
                // If full URL pasted
                if (/^https?:\/\//i.test(input)) {
                    const u = new URL(input);
                    const parts = u.pathname.split('/').filter(Boolean);
                    const idx = parts.findIndex(p => p.toLowerCase() === 'invite');
                    if (idx >= 0 && parts[idx + 1]) return parts[idx + 1].toUpperCase();
                }
            } catch {}
            // If looks like `/invite/ABC123`
            const m = input.match(/invite\/?([A-Za-z0-9]+)/i);
            if (m) return m[1].toUpperCase();
            // Otherwise assume it's the code
            return (input || '').toString().trim().toUpperCase();
        }

        async function joinServerFromPreview() {
            if (!pendingInviteCode) return;
            try {
                const resp = await fetch('/api/servers/join', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ inviteCode: pendingInviteCode })
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to join server', 'error');
                    return;
                }
                hideServerPreviewModal();
                showNotification('Joined server successfully', 'success');
                await loadUserServers();
                // Optionally auto-switch to the new server
                if (data.server) {
                    selectServer(data.server);
                }
            } catch (err) {
                console.error('Join from preview failed:', err);
                showNotification('Failed to join server', 'error');
            }
        }

        // Server Settings Modal Functions
        function showServerSettings() {
            console.log('showServerSettings called');
            console.log('currentServer:', currentServer);
            console.log('currentUser:', currentUser);
            
            // Allow owners and admins to open settings; certain tabs enforce stricter rules below
            const isOwner = currentServer && currentServer.ownerId === currentUser.id;
            const isAdminMember = (() => {
                // Try to use currentServer.role if present; else deduce from members cache
                if (currentServer && currentServer.role) return currentServer.role === 'admin';
                const m = Array.from(currentServerMembersMap.entries()).find(([uid]) => uid === currentUser.id);
                return m ? (m[1].role === 'admin') : false;
            })();
            if (!currentServer || (!isOwner && !isAdminMember)) {
                showNotification('Only server owners/admins can access server settings', 'error');
                return;
            }

            // Populate server info
            document.getElementById('server-settings-title').textContent = `${currentServer.name} Settings`;
            document.getElementById('edit-server-name').value = currentServer.name || '';
            document.getElementById('edit-server-description').value = currentServer.description || '';
            
            // Populate icon preview
            const iconEl = document.getElementById('server-settings-icon');
            iconEl.textContent = '';
            if (currentServer.icon) {
                // Clear any inline background shorthand that could override sub-properties
                iconEl.style.removeProperty('background');
                iconEl.style.backgroundImage = `url(${currentServer.icon})`;
                iconEl.style.backgroundSize = 'cover';
                iconEl.style.backgroundPosition = 'center';
                iconEl.style.backgroundRepeat = 'no-repeat';
                iconEl.style.backgroundColor = 'transparent';
            } else {
                iconEl.style.backgroundImage = '';
                iconEl.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue('--brand-2') || '#ff2241';
                iconEl.textContent = currentServer.name ? currentServer.name.charAt(0).toUpperCase() : '?';
            }

            // Click to change icon (opens file picker → cropper modal)
            iconEl.onclick = () => document.getElementById('server-icon-input').click();
            const iconInput = document.getElementById('server-icon-input');
            iconInput.onchange = (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) {
                    openIconCropper(ev.target.result);
                };
                reader.readAsDataURL(file);
            };

            // Switch to general tab and show modal
            switchServerSettingsTab('general');
            document.getElementById('server-settings-modal').style.display = 'block';
        }

        function hideServerSettings() {
            document.getElementById('server-settings-modal').style.display = 'none';
        }

        function switchServerSettingsTab(tab) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            // Show selected tab
            const sel = document.getElementById(tab + '-tab');
            if (sel) sel.classList.add('active');
            // Update vertical nav active state
            document.querySelectorAll('.settings-nav-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });
            // Tab-specific data
            if (tab === 'members') {
                loadServerMembersForSettings();
            } else if (tab === 'roles') {
                loadServerRoles();
            } else if (tab === 'kick') {
                loadKickableMembers();
            } else if (tab === 'admins') {
                loadAdminsManagement();
            } else if (tab === 'delete') {
                const note = document.getElementById('delete-owner-note');
                const btn = document.getElementById('delete-server-open-btn');
                if (currentServer && currentUser && currentServer.ownerId !== currentUser.id) {
                    if (note) note.style.display = 'block';
                    if (btn) { btn.disabled = true; btn.title = 'Only the owner can delete the server'; }
                } else {
                    if (note) note.style.display = 'block';
                    if (btn) { btn.disabled = false; btn.title = ''; }
                }
            }
        }

        // Delete server flow (custom modals)
        function openDeleteServerConfirm() {
            if (!currentServer) return;
            if (currentUser && currentServer.ownerId !== currentUser.id) {
                showNotification('Only the owner can delete this server', 'error');
                return;
            }
            document.getElementById('del-modal-server-name-1').textContent = currentServer.name;
            document.getElementById('delete-server-confirm-modal').style.display = 'block';
        }

        function proceedDeleteServerVerify() {
            document.getElementById('delete-server-confirm-modal').style.display = 'none';
            document.getElementById('del-modal-server-name-2').textContent = `"${currentServer.name}"`;
            const input = document.getElementById('delete-server-name-input');
            const btn = document.getElementById('confirm-delete-server-btn');
            input.value = '';
            btn.disabled = true;
            input.oninput = () => { btn.disabled = input.value.trim() !== (currentServer.name || '').trim(); };
            document.getElementById('delete-server-verify-modal').style.display = 'block';
            input.focus();
        }

        function cancelDeleteServerFlow() {
            document.getElementById('delete-server-confirm-modal').style.display = 'none';
            document.getElementById('delete-server-verify-modal').style.display = 'none';
        }

        async function performDeleteServer() {
            try {
                // Snapshot details early in case a socket event resets currentServer mid-flight
                if (!currentServer) {
                    // If a recent server-deleted event already occurred, treat as handled
                    if (lastDeletedServerEvent.id) { cancelDeleteServerFlow(); hideServerSettings(); selectHome(); return; }
                    showNotification('No server selected to delete', 'error');
                    return;
                }
                const deletingId = parseFloat(currentServer.id);
                const deletingName = currentServer.name;
                // Mark this delete as locally initiated to prevent duplicate socket toasts
                pendingLocalServerDelete = { id: deletingId, at: Date.now() };

                const resp = await fetch(`/api/servers/${deletingId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                let data = null;
                try { data = await resp.json(); } catch (_) { /* empty or text body */ }
                // Some environments send a socket event but return a non-JSON body; treat socket event as source of truth
                if (!resp.ok) {
                    // If we just observed a matching server-deleted event recently, treat as success
                    const expectedId = deletingId;
                    const recently = lastDeletedServerEvent.id === expectedId && (Date.now() - lastDeletedServerEvent.at) < 2000;
                    if (!recently) {
                        showNotification((data && (data.error || data.message)) || 'Failed to delete server', 'error');
                        return;
                    }
                }
                const deletedId = deletingId;
                const deletedName = deletingName;
                if (socket && currentChannel && currentChannel.id) {
                    socket.emit('leave-channel', currentChannel.id);
                }
                const icon = document.querySelector(`.server-icon[data-server-id="${deletedId}"]`);
                if (icon) { icon.classList.add('pop-out'); setTimeout(() => icon.remove(), 240); }
                userServers = userServers.filter(s => parseFloat(s.id) !== deletedId);
                displayUserServers();
                // Ensure any modals are closed immediately
                cancelDeleteServerFlow();
                hideServerSettings();
                selectHome();
                // Show a single toast here; socket listener will suppress its own
                showNotification(`"${deletedName}" deleted`, 'error');
            } catch (e) {
                console.error('Delete server error:', e);
                showNotification('Failed to delete server', 'error');
            }
        }

        async function loadKickableMembers() {
            const list = document.getElementById('kick-members-list');
            const note = document.getElementById('kick-permission-note');
            list.innerHTML = 'Loading...';
            note.textContent = '';
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/members`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                if (!resp.ok) { list.innerHTML = 'Failed to load members'; return; }
                const data = await resp.json();
                const members = data.members || [];
                const actor = members.find(m => m.userId === currentUser.id);
                const actorRole = actor ? actor.role : 'member';
                const rows = members
                    .filter(m => m.userId !== currentUser.id)
                    .filter(m => m.role !== 'owner')
                    .filter(m => actorRole === 'owner' ? true : m.role === 'member');
                list.innerHTML = rows.length ? rows.map(m => `
                    <div class="member-item" style="display:flex; align-items:center; justify-content:space-between; padding:6px 10px; border-radius:6px;">
                        <div style="display:flex; align-items:center; gap:8px; min-width:0; flex:1;">
                            <div class="${m.avatar ? 'member-avatar has-image' : 'member-avatar'}" ${m.avatar
                                ? `style="background-image:url(${m.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;"`
                                : `style="background:${getUserAvatarGradient({ id: m.userId, username: m.username })}"`}>
                                ${m.avatar ? '' : (m.username ? m.username.charAt(0).toUpperCase() : '?')}
                            </div>
                            <span class="member-username" title="${m.username}" style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; display:block; max-width:100%;">${m.username}</span>
                            <span style="color:#b9bbbe; font-size:12px; flex:0 0 auto;">(${m.role})</span>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="kickMember(${m.userId})">Kick</button>
                    </div>
                `).join('') : '<div>No members available to kick</div>';
                if (actorRole !== 'owner') note.textContent = 'Admins can kick members only.';
            } catch (e) {
                console.error('Kick list error', e);
                list.innerHTML = 'Error loading members';
            }
        }

        async function kickMember(userId) {
            if (!confirm('Are you sure you want to kick this member?')) return;
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/members/${userId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to kick member', 'error');
                    return;
                }
                showNotification('Member kicked');
                loadKickableMembers();
                loadServerMembersForSettings();
                await loadServerMembersCache(currentServer.id);
                document.querySelectorAll('#messages-container .message-author').forEach(async el => {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                });
            } catch (e) {
                console.error('Kick error', e);
                showNotification('Failed to kick member', 'error');
            }
        }

        async function loadAdminsManagement() {
            const list = document.getElementById('admins-list');
            const note = document.getElementById('admins-permission-note');
            list.innerHTML = 'Loading...';
            note.textContent = '';
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/members`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                if (!resp.ok) { list.innerHTML = 'Failed to load members'; return; }
                const data = await resp.json();
                const members = data.members || [];
                const actor = members.find(m => m.userId === currentUser.id);
                if (!actor || actor.role !== 'owner') {
                    list.innerHTML = '<div>Only the server owner can manage admins.</div>';
                    note.textContent = 'You must be the owner to promote/demote admins.';
                    return;
                }
                const rows = members.filter(m => m.role !== 'owner' && m.userId !== currentUser.id);
                list.innerHTML = rows.length ? rows.map(m => `
                    <div class="member-item" style="display:flex; align-items:center; justify-content:space-between; padding:6px 10px; border-radius:6px;">
                        <div style="display:flex; align-items:center; gap:8px; min-width:0; flex:1;">
                            <div class="${m.avatar ? 'member-avatar has-image' : 'member-avatar'}" ${m.avatar
                                ? `style=\"background-image:url(${m.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;\"`
                                : `style=\"background:${getUserAvatarGradient({ id: m.userId, username: m.username })}\"`}>
                                ${m.avatar ? '' : (m.username ? m.username.charAt(0).toUpperCase() : '?')}
                            </div>
                            <span class="member-username" title="${m.username}" style="white-space:nowrap; overflow:hidden; text-overflow:ellipsis; display:block; max-width:100%;">${m.username}</span>
                            <span style="color:#b9bbbe; font-size:12px; flex:0 0 auto;">(${m.role})</span>
                        </div>
                        ${m.role === 'admin' ?
                            `<button class=\"btn btn-sm btn-secondary\" style=\"white-space:nowrap;\" onclick=\"promoteDemoteAdmin(${m.userId}, 'member')\">Demote</button>` :
                            `<button class=\"btn btn-sm btn-secondary\" style=\"white-space:nowrap;\" onclick=\"promoteDemoteAdmin(${m.userId}, 'admin')\">Promote</button>`
                        }
                    </div>
                `).join('') : '<div>No members to manage</div>';
            } catch (e) {
                console.error('Admins tab load error', e);
                list.innerHTML = 'Error loading members';
            }
        }

        async function promoteDemoteAdmin(userId, targetRole) {
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/members/${userId}/role`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ role: targetRole })
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to update admin status', 'error');
                    return;
                }
                showNotification(targetRole === 'admin' ? 'Promoted to admin' : 'Demoted to member');
                loadAdminsManagement();
                loadServerMembersForSettings();
                await loadServerMembersCache(currentServer.id);
                document.querySelectorAll('#messages-container .message-author').forEach(async el => {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                });
            } catch (e) {
                console.error('Promote/demote admin error', e);
                showNotification('Failed to update admin status', 'error');
            }
        }

        async function updateServerSettings(event) {
            event.preventDefault();
            
            const name = document.getElementById('edit-server-name').value.trim();
            const description = document.getElementById('edit-server-description').value.trim();
            const iconEl = document.getElementById('server-settings-icon');
            const previewDataUrl = iconEl?.dataset?.previewDataUrl; // optional
            
            if (!name) {
                showNotification('Server name is required', 'error');
                return;
            }

            try {
                const body = { name, description };
                if (previewDataUrl) {
                    body.icon = previewDataUrl; // send Data URL; backend already supports updating icon field
                }
                const response = await fetch(`/api/servers/${currentServer.id}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(body)
                });

                if (response.ok) {
                    const payload = await response.json();
                    const updated = payload.server || payload; // handle { server, message } or just server
                    currentServer.name = updated.name ?? currentServer.name;
                    currentServer.description = updated.description ?? currentServer.description;
                    if (typeof updated.icon !== 'undefined') {
                        currentServer.icon = updated.icon;
                    } else if (body.icon) {
                        currentServer.icon = body.icon;
                    }

                    // Update UI
                    document.getElementById('current-server-name').textContent = currentServer.name;
                    // Update icon in sidebar (if present)
                    const sidebarIcon = document.querySelector(`.server-icon[data-server-id="${currentServer.id}"]`);
                    if (sidebarIcon) {
                        if (currentServer.icon) {
                            const isData = typeof currentServer.icon === 'string' && currentServer.icon.startsWith('data:image');
                            const bust = isData ? currentServer.icon : `${currentServer.icon}${currentServer.icon.includes('?') ? '&' : '?'}v=${Date.now()}`;
                            sidebarIcon.style.backgroundImage = `url(${bust})`;
                            sidebarIcon.style.backgroundSize = 'cover';
                            sidebarIcon.style.backgroundPosition = 'center';
                            sidebarIcon.style.backgroundRepeat = 'no-repeat';
                            sidebarIcon.classList.add('has-image');
                            sidebarIcon.textContent = '';
                        } else {
                            sidebarIcon.style.backgroundImage = '';
                            sidebarIcon.classList.remove('has-image');
                            sidebarIcon.textContent = currentServer.name.charAt(0).toUpperCase();
                        }
                    }
                    // Update settings icon preview state
                    const iconEl = document.getElementById('server-settings-icon');
                    if (iconEl) {
                        iconEl.dataset.previewDataUrl = '';
                        if (currentServer.icon) {
                            const isData2 = typeof currentServer.icon === 'string' && currentServer.icon.startsWith('data:image');
                            const bust2 = isData2 ? currentServer.icon : `${currentServer.icon}${currentServer.icon.includes('?') ? '&' : '?'}v=${Date.now()}`;
                            iconEl.style.backgroundImage = `url(${bust2})`;
                            iconEl.style.backgroundSize = 'cover';
                            iconEl.style.backgroundPosition = 'center';
                            iconEl.style.backgroundRepeat = 'no-repeat';
                            iconEl.style.backgroundColor = 'transparent';
                            iconEl.textContent = '';
                        } else {
                            iconEl.style.backgroundImage = '';
                            iconEl.style.background = 'var(--brand-2)';
                            iconEl.textContent = currentServer.name.charAt(0).toUpperCase();
                        }
                    }
                    showNotification('Server settings updated successfully');
                } else {
                    const error = await response.json();
                    showNotification(error.message || 'Failed to update server settings', 'error');
                }
            } catch (error) {
                console.error('Update server error:', error);
                showNotification('Failed to update server settings', 'error');
            }
        }

        async function loadServerMembersForSettings() {
            console.log('=== loadServerMembersForSettings called ===');
            console.log('currentServer:', currentServer);
            console.log('currentUser:', currentUser);
            
            if (!currentServer) {
                console.error('No current server selected');
                return;
            }
            
            console.log('Current server:', currentServer);
            console.log('Current server ID:', currentServer.id);
            console.log('Current server ownerId:', currentServer.ownerId);
            
            const membersList = document.getElementById('server-members-list');
            membersList.innerHTML = '<div>Loading members...</div>';
            
            // Add temporary test data to verify the UI works
            /*
            membersList.innerHTML = `
                <div class="member-item">
                    <div class="member-info">
                        <div class="member-avatar" style="color: #43b581">T</div>
                        <div class="member-details">
                            <div class="member-username" style="color: #43b581">Test Owner</div>
                            <div class="member-role">Server Owner</div>
                        </div>
                    </div>
                    <div class="member-actions">
                        <span style="color: #43b581;">Server Owner</span>
                    </div>
                </div>
            `;
            return;
            */
            
            try {
                const url = `/api/servers/${currentServer.id}/members`;
                console.log('Fetching from URL:', url);
                
                const response = await fetch(url, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Members data:', data);
                    
                    if (data.members && data.members.length > 0) {
                        // Fetch roles to build custom role dropdowns
                        const rolesResp = await fetch(`/api/servers/${currentServer.id}/roles`, {
                            headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                        });
                        const rolesData = rolesResp.ok ? await rolesResp.json() : { roles: [] };
                        const customRoles = (rolesData.roles || []).filter(r => !r.isDefault);
                        // Add a nice header with member count
                        membersList.innerHTML = `
                            <div style="
                                padding: 16px;
                                border-bottom: 1px solid #4f545c;
                                margin-bottom: 12px;
                                background: rgba(114, 137, 218, 0.05);
                                border-radius: 4px;
                            ">
                                <h3 style="
                                    color: #dcddde;
                                    font-size: 16px;
                                    margin: 0 0 8px 0;
                                    display: flex;
                                    align-items: center;
                                    gap: 8px;
                                ">
                                    👥 Server Members
                                    <span style="
                                        background: #7289da;
                                        color: white;
                                        padding: 2px 8px;
                                        border-radius: 12px;
                                        font-size: 12px;
                                        font-weight: normal;
                                    ">${data.members.length}</span>
                                </h3>
                                <p style="color: #b9bbbe; font-size: 13px; margin: 0;">
                                    Manage server members and their roles
                                </p>
                            </div>
                        ` + data.members.map(member => `
                            <div class="member-item" data-user-id="${member.userId}" data-base-role="${member.role}" data-role-id="${member.roleId ?? ''}" style="display: flex; align-items: center; padding: 4px 10px; margin-bottom: 4px; border-radius: 6px;">
                                <div class="member-info" style="display: flex; align-items: center; gap: 8px; flex: 1; min-width: 0;">
                                    <div class="member-avatar ${member.avatar ? 'has-image' : ''}" style="
                                        width: 24px;
                                        height: 24px;
                                        border-radius: 50%;
                                        ${member.avatar 
                                            ? `background-image:url(${member.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;` 
                                            : `background: ${getUserAvatarGradient({ id: member.userId, username: member.username })}`}
                                        display: flex;
                                        align-items: center;
                                        justify-content: center;
                                        font-weight: 600;
                                        font-size: 12px;
                                        color: white;
                                    ">${member.avatar ? '' : member.username[0].toUpperCase()}</div>
                                    <span class="member-username" style="
                                        color: ${member.role === 'owner' ? '#43b581' : '#dcddde'};
                                        font-weight: 500;
                                        font-size: 13px;
                                        display: inline-block;
                                        flex: 1 1 auto;
                                        margin: 0;
                                        white-space: nowrap;
                                        overflow: hidden;
                                        text-overflow: ellipsis;
                                        max-width: 100%;
                                    ">${member.username}</span>
                                </div>
                                <div class="member-actions" style="margin-left: auto; display: inline-flex; align-items: center; gap: 8px; white-space: nowrap;">
                                    ${member.role === 'owner' ? 
                                        '<span style="color: #43b581; font-size: 12px; padding: 4px 8px; background: rgba(67, 181, 129, 0.1); border-radius: 12px; border: 1px solid rgba(67, 181, 129, 0.3);">Owner</span>' : 
                                        `<select title="Custom role" style="background: #40444b; color: #dcddde; border: 1px solid #4f545c; border-radius: 4px; padding: 2px 8px; font-size: 12px; cursor: pointer;" onchange="updateMemberCustomRole(${member.userId}, this.value)">
                                            <option value="">No role</option>
                                            ${customRoles.map(r => `<option value="${r.id}" ${member.roleId == r.id ? 'selected' : ''}>${r.name}</option>`).join('')}
                                        </select>`
                                    }
                                </div>
                            </div>
                        `).join('');

                        // Apply role colors after rendering
                        applyRoleColors();
                    } else {
                        membersList.innerHTML = '<div>No members found</div>';
                    }
                } else {
                    console.error('API error response status:', response.status);
                    const errorText = await response.text();
                    console.error('API error response body:', errorText);
                    membersList.innerHTML = '<div>Failed to load members</div>';
                }
            } catch (error) {
                console.error('Load members error:', error);
                membersList.innerHTML = '<div>Error loading members</div>';
            }
        }

        function loadServerRoles() {
            const rolesList = document.getElementById('roles-list');
            rolesList.innerHTML = '<div>Loading roles...</div>';

            (async () => {
                try {
                    const resp = await fetch(`/api/servers/${currentServer.id}/roles`, {
                        headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                    });
                    if (!resp.ok) {
                        const t = await resp.text();
                        rolesList.innerHTML = `<div>Failed to load roles</div>`;
                        console.error('Load roles error:', t);
                        return;
                    }
                    const data = await resp.json();
                    const roles = data.roles || [];

                    if (!roles.length) {
                        rolesList.innerHTML = '<div>No roles yet</div>';
                        return;
                    }

                    rolesList.innerHTML = roles.map(r => `
                        <div class="role-item">
                            <div>
                                <span class="role-name" style="color: ${r.color};">${escapeHtml(r.name)}</span>
                                ${r.isDefault ? '<span style="color: #b9bbbe; font-size: 12px;">Default role for all members</span>' : ''}
                            </div>
                            <div class="role-actions">
                                ${r.isDefault ? '<button class="btn btn-sm btn-secondary" disabled>Default Role</button>' : `
                                    <button class="btn btn-sm" onclick="editRole(${r.id})">Edit</button>
                                    <button class="btn btn-sm btn-secondary" onclick="deleteRole(${r.id})">Delete</button>
                                `}
                            </div>
                        </div>
                    `).join('');
                } catch (err) {
                    console.error('Roles load error:', err);
                    rolesList.innerHTML = '<div>Error loading roles</div>';
                }
            })();
        }

        function showCreateRoleForm() {
            document.getElementById('create-role-form').style.display = 'block';
        }

        function hideCreateRoleForm() {
            document.getElementById('create-role-form').style.display = 'none';
            document.getElementById('new-role-name').value = '';
            document.getElementById('new-role-color').value = '#5865f2';
            // Reset checkboxes
            document.querySelectorAll('.permissions-list input[type="checkbox"]').forEach(cb => cb.checked = false);
        }

        async function deleteRole(roleId) {
            if (!currentServer) return;
            if (!confirm('Delete this role?')) return;
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/roles/${roleId}`, {
                    method: 'DELETE',
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to delete role', 'error');
                    return;
                }
                showNotification('Role deleted');
                loadServerRoles();
                // Also refresh members for color updates
                loadServerMembersForSettings();
                await loadServerMembersCache(currentServer.id);
                document.querySelectorAll('#messages-container .message-author').forEach(async el => {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                });
            } catch (err) {
                console.error('Delete role error:', err);
                showNotification('Failed to delete role', 'error');
            }
        }

        async function editRole(roleId) {
            if (!currentServer) return;
            // Simple prompt-based editing for now
            try {
                // Fetch existing role
                const rolesResp = await fetch(`/api/servers/${currentServer.id}/roles`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                if (!rolesResp.ok) return;
                const rolesData = await rolesResp.json();
                const role = (rolesData.roles || []).find(r => r.id == roleId);
                if (!role) return;
                const newName = prompt('Role name:', role.name);
                if (newName === null) return;
                const newColor = prompt('Role color (hex):', role.color || '#5865f2');
                if (newColor === null) return;
                const resp = await fetch(`/api/servers/${currentServer.id}/roles/${roleId}`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ name: newName.trim(), color: newColor })
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to update role', 'error');
                    return;
                }
                showNotification('Role updated');
                loadServerRoles();
                loadServerMembersForSettings();
                await loadServerMembersCache(currentServer.id);
                document.querySelectorAll('#messages-container .message-author').forEach(async el => {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                });
            } catch (err) {
                console.error('Edit role error:', err);
                showNotification('Failed to update role', 'error');
            }
        }

        async function createRole(event) {
            event.preventDefault();
            const name = document.getElementById('new-role-name').value.trim();
            const color = document.getElementById('new-role-color').value;
            const permissions = [];
            if (document.getElementById('perm-manage-channels').checked) permissions.push('manage_channels');
            if (document.getElementById('perm-manage-members').checked) permissions.push('manage_members');
            if (document.getElementById('perm-kick-members').checked) permissions.push('kick_members');
            if (document.getElementById('perm-ban-members').checked) permissions.push('ban_members');
            if (document.getElementById('perm-create-invite').checked) permissions.push('create_invite');

            if (!name) {
                showNotification('Role name is required', 'error');
                return;
            }
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/roles`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ name, color, permissions })
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to create role', 'error');
                    return;
                }
                showNotification('Role created');
                hideCreateRoleForm();
                loadServerRoles();
                await loadServerMembersCache(currentServer.id);
                document.querySelectorAll('#messages-container .message-author').forEach(async el => {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                });
            } catch (error) {
                console.error('Create role error:', error);
                showNotification('Failed to create role', 'error');
            }
        }

        // Update member role (for server owners/admins)
        async function updateMemberRole(userId, newRole) {
            if (!currentServer) return;
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/members/${userId}/role`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ role: newRole })
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to update member role', 'error');
                    return;
                }
                showNotification('Member role updated');
                // Refresh member list to reflect colors/order
                loadServerMembersForSettings();
                await loadServerMembersCache(currentServer.id);
                document.querySelectorAll('#messages-container .message-author').forEach(async el => {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                });
            } catch (error) {
                console.error('Update member role error:', error);
                showNotification('Failed to update member role', 'error');
            }
        }

        async function updateMemberCustomRole(userId, roleIdValue) {
            if (!currentServer) return;
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/members/${userId}/role`, {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ roleId: roleIdValue ? parseFloat(roleIdValue) : null })
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to update custom role', 'error');
                    return;
                }
                showNotification('Custom role updated');
                loadServerMembersForSettings();
                await loadServerMembersCache(currentServer.id);
                document.querySelectorAll('#messages-container .message-author').forEach(async el => {
                    const uid = el.getAttribute('data-user-id');
                    if (uid) await applyRoleColorToAuthorElement(el, uid);
                });
            } catch (error) {
                console.error('Update member custom role error:', error);
                showNotification('Failed to update custom role', 'error');
            }
        }

        

        // Role color display functions
        async function getServerRolesMap() {
            try {
                const resp = await fetch(`/api/servers/${currentServer.id}/roles`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token')}` }
                });
                if (!resp.ok) return {};
                const data = await resp.json();
                const map = {};
                (data.roles || []).forEach(r => { map[r.id] = r; });
                return map;
            } catch { return {}; }
        }

        async function getMemberRoleColor(userId, serverId, roleId, baseRole) {
            // Prefer custom role color when assigned
            const rolesMap = await getServerRolesMap();
            if (roleId && rolesMap[roleId] && rolesMap[roleId].color) {
                return rolesMap[roleId].color;
            }
            if (baseRole === 'owner') return '#43b581';
            if (baseRole === 'admin') return '#7289da';
            return '#dcddde';
        }

        async function applyRoleColors() {
            if (!currentServer) return;
            const rolesMap = await getServerRolesMap();
            document.querySelectorAll('#server-members-list .member-item').forEach(item => {
                const userId = parseInt(item.dataset.userId || '0');
                const nameEl = item.querySelector('.member-username');
                const baseRole = (item.dataset.baseRole || 'member');
                const roleId = item.dataset.roleId ? parseFloat(item.dataset.roleId) : null;
                if (nameEl) {
                    let color = '#dcddde';
                    if (roleId && rolesMap[roleId] && rolesMap[roleId].color) color = rolesMap[roleId].color;
                    else if (baseRole === 'owner') color = '#43b581';
                    else if (baseRole === 'admin') color = '#7289da';
                    nameEl.style.color = color;
                }
            });
        }

        // ===== Server Icon Cropper Logic =====
        let cropperState = {
            imgEl: null,
            stageEl: null,
            viewportEl: null,
            zoomEl: null,
            zoom: 1,
            imgNatural: { w: 0, h: 0 },
            pos: { x: 0, y: 0 },
            dragging: false,
            dragStart: { x: 0, y: 0 },
            posStart: { x: 0, y: 0 },
        };

        function openIconCropper(dataUrl) {
            cropperState.imgEl = document.getElementById('cropper-img');
            cropperState.stageEl = document.getElementById('cropper-stage');
            cropperState.viewportEl = document.getElementById('cropper-viewport');
            cropperState.zoomEl = document.getElementById('cropper-zoom');
            document.getElementById('cropper-zoom-value').textContent = '1.00×';
            cropperState.zoomEl.value = '1';
            cropperState.zoom = 1;
            cropperState.pos = { x: 0, y: 0 };

            cropperState.imgEl.onload = () => {
                cropperState.imgNatural = { w: cropperState.imgEl.naturalWidth, h: cropperState.imgEl.naturalHeight };
                // Fit image to cover viewport at scale 1
                const v = cropperState.viewportEl.getBoundingClientRect();
                const scaleToCover = Math.max(v.width / cropperState.imgNatural.w, v.height / cropperState.imgNatural.h);
                // Base size at scale 1
                cropperState.imgEl.style.width = `${cropperState.imgNatural.w * scaleToCover}px`;
                cropperState.imgEl.style.height = `${cropperState.imgNatural.h * scaleToCover}px`;
                cropperState.pos = { x: 0, y: 0 };
                applyCropperTransform();
            };
            cropperState.imgEl.src = dataUrl;

            // Handlers
            cropperState.zoomEl.oninput = () => {
                cropperState.zoom = parseFloat(cropperState.zoomEl.value);
                document.getElementById('cropper-zoom-value').textContent = `${cropperState.zoom.toFixed(2)}×`;
                applyCropperTransform();
            };

            const onDown = (clientX, clientY) => {
                cropperState.dragging = true;
                cropperState.stageEl.classList.add('dragging');
                cropperState.dragStart = { x: clientX, y: clientY };
                cropperState.posStart = { ...cropperState.pos };
            };
            const onMove = (clientX, clientY) => {
                if (!cropperState.dragging) return;
                const dx = clientX - cropperState.dragStart.x;
                const dy = clientY - cropperState.dragStart.y;
                cropperState.pos = { x: cropperState.posStart.x + dx, y: cropperState.posStart.y + dy };
                applyCropperTransform();
            };
            const onUp = () => {
                cropperState.dragging = false;
                cropperState.stageEl.classList.remove('dragging');
            };

            // Mouse events
            cropperState.stageEl.onmousedown = (e) => onDown(e.clientX, e.clientY);
            window.addEventListener('mousemove', (e) => onMove(e.clientX, e.clientY));
            window.addEventListener('mouseup', onUp);
            // Touch events
            cropperState.stageEl.ontouchstart = (e) => {
                if (e.touches.length > 0) {
                    const t = e.touches[0];
                    onDown(t.clientX, t.clientY);
                }
            };
            window.addEventListener('touchmove', (e) => {
                if (e.touches.length > 0) {
                    const t = e.touches[0];
                    onMove(t.clientX, t.clientY);
                }
            }, { passive: false });
            window.addEventListener('touchend', onUp);

            document.getElementById('icon-cropper-modal').style.display = 'block';
            // Lock background scroll
            document.body.style.overflow = 'hidden';
        }

        function hideIconCropper() {
            document.getElementById('icon-cropper-modal').style.display = 'none';
            // Restore background scroll
            document.body.style.overflow = '';
        }

        function applyCropperTransform() {
            const img = cropperState.imgEl;
            if (!img) return;
            const scale = cropperState.zoom;
            img.style.transform = `translate(${cropperState.pos.x}px, ${cropperState.pos.y}px) scale(${scale})`;
        }

        function applyIconCrop() {
            // Render circular crop to canvas 256x256
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Clip circle
            ctx.clearRect(0, 0, size, size);
            ctx.save();
            ctx.beginPath();
            ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
            ctx.closePath();
            ctx.clip();

            // Compute image draw params
            const vRect = cropperState.viewportEl.getBoundingClientRect();
            const imgEl = cropperState.imgEl;
            const displayedWidth = imgEl.getBoundingClientRect().width;
            const displayedHeight = imgEl.getBoundingClientRect().height;
            // Position within viewport: we use cropperState.pos relative to stage center
            // Map viewport center to canvas center
            const scaleRatioX = size / vRect.width;
            const scaleRatioY = size / vRect.height;

            // Calculate top-left of image within viewport coordinates
            const imgLeftInViewport = (vRect.width - displayedWidth) / 2 + cropperState.pos.x;
            const imgTopInViewport = (vRect.height - displayedHeight) / 2 + cropperState.pos.y;

            // Draw image scaled to canvas space
            ctx.drawImage(
                imgEl,
                imgLeftInViewport * scaleRatioX,
                imgTopInViewport * scaleRatioY,
                displayedWidth * scaleRatioX,
                displayedHeight * scaleRatioY
            );

            ctx.restore();
            const dataUrl = canvas.toDataURL('image/png');

            // Preview on settings icon and stash for save
            const iconEl = document.getElementById('server-settings-icon');
            iconEl.style.backgroundImage = `url(${dataUrl})`;
            iconEl.style.backgroundSize = 'cover';
            iconEl.style.backgroundPosition = 'center';
            iconEl.style.backgroundRepeat = 'no-repeat';
            iconEl.style.backgroundColor = 'transparent';
            iconEl.textContent = '';
            iconEl.dataset.previewDataUrl = dataUrl;

            hideIconCropper();
        }

        // Utility functions
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Convert URLs in message text into safe, clickable links
        function linkifyMessageText(text) {
            if (!text) return '';
            // Escape first to avoid injecting HTML
            const safe = escapeHtml(text);
            // Regex for URLs (http/https) with basic TLD/domain/path matching
            const urlRegex = /\bhttps?:\/\/[\w.-]+(?:\:[0-9]+)?(?:\/[\w\-._~%!$&'()*+,;=:@/?#]*)?/gi;
            let linked = safe.replace(urlRegex, (url) => {
                // Prevent double-escaping by using the matched, already-escaped string as text
                const href = url;
                return `<a class="chat-link" href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
            });
            // Also linkify bare www. domains
            const wwwRegex = /(^|\s)(www\.[\w.-]+(?:\:[0-9]+)?(?:\/[\w\-._~%!$&'()*+,;=:@/?#]*)?)/gi;
            linked = linked.replace(wwwRegex, (match, pre, url) => {
                const href = `http://${url}`;
                return `${pre}<a class="chat-link" href="${href}" target="_blank" rel="noopener noreferrer">${url}</a>`;
            });
            return linked;
        }

        // Show notification to user
        function showNotification(message, type = 'success') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            // Style the notification
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                max-width: 300px;
                word-wrap: break-word;
                transition: all 0.3s ease;
                background: ${type === 'error' ? 'var(--brand-gradient)' : 'linear-gradient(135deg, #51cf66, #40c057)'};
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffInSeconds = Math.floor((now - date) / 1000);
            
            if (diffInSeconds < 60) {
                return diffInSeconds <= 1 ? 'just now' : `${diffInSeconds}s ago`;
            }
            
            const diffInMinutes = Math.floor(diffInSeconds / 60);
            if (diffInMinutes < 60) {
                return `${diffInMinutes}m ago`;
            }
            
            const diffInHours = Math.floor(diffInMinutes / 60);
            if (diffInHours < 24) {
                return `${diffInHours}h ago`;
            }
            
            const diffInDays = Math.floor(diffInHours / 24);
            return `${diffInDays}d ago`;
        }

        function scrollToBottom() {
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Main Friends UI Functions
        function showFriendsMain() {
            currentView = 'friends';
            currentChannel = null;
            currentServer = null;
            
            // Reset chat area state to prevent friends container from inheriting expanded width
            const chatArea = document.getElementById('chat-area');
            chatArea.classList.add('no-transition');
            chatArea.classList.remove('expanded');
            
            // Update UI visibility
            document.getElementById('messages-container').style.display = 'none';
            document.getElementById('friends-main-area').style.display = 'flex';
            document.getElementById('message-input-area').style.display = 'none';
            
            // Re-enable transitions after DOM update
            requestAnimationFrame(() => {
                chatArea.classList.remove('no-transition');
            });
            
            // Update sidebar selection
            document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
            document.querySelectorAll('.dm-item').forEach(item => item.classList.remove('active')); // Unhighlight DM items
            document.querySelector('[onclick="showFriendsMain()"]').classList.add('active');
            
            // Update server list
            document.querySelectorAll('.server-icon').forEach(icon => icon.classList.remove('active'));
            document.querySelector('.server-icon.home').classList.add('active');
            
            // Update header
            document.getElementById('current-server-name').textContent = 'Friends';
            document.getElementById('header-icon').textContent = '👥';
            document.getElementById('current-channel-name').textContent = 'Friends';
            document.getElementById('current-channel-info').textContent = 'Manage your friends and connections';
            
            // Load current tab content
            switchFriendsTab('current');
        }
        
        function switchFriendsTab(tab) {
            console.log('Switching to friends tab:', tab);
            
            // Update nav buttons
            document.querySelectorAll('.friends-nav-btn-main').forEach(btn => btn.classList.remove('active'));
            const activeButton = document.querySelector(`[onclick="switchFriendsTab('${tab}')"]`);
            if (activeButton) {
                activeButton.classList.add('active');
            } else {
                console.error('Could not find friends tab button for:', tab);
            }
            
            // Hide all tab contents
            document.querySelectorAll('.friends-tab-main').forEach(content => content.classList.remove('active'));
            
            // Show selected tab content
            let contentId;
            if (tab === 'pending') {
                contentId = 'pending-requests-content';
            } else {
                contentId = `${tab}-friends-content`;
            }
            
            const tabContent = document.getElementById(contentId);
            if (tabContent) {
                tabContent.classList.add('active');
            } else {
                console.error('Could not find friends tab content for:', tab, 'tried ID:', contentId);
            }
            
            // Load content based on tab
            if (tab === 'current') {
                loadCurrentFriends();
            } else if (tab === 'add') {
                setupUsernameSearch();
            } else if (tab === 'pending') {
                loadPendingRequestsMain();
                updatePendingRequestsBadge();
            }
        }
        
        // Load current friends in grid format
        async function loadCurrentFriends() {
            try {
                const response = await fetch('/api/friends', {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                const data = await response.json();
                const friendsGrid = document.getElementById('current-friends-grid');
                
                if (data.friends && data.friends.length > 0) {
                    friendsGrid.innerHTML = data.friends.map(friend => `
                        <div class="friend-card" onclick="openUserProfile('${friend.id}', '${friend.username}', ${friend.avatar ? `\'${friend.avatar}\'` : 'null'})">
                            <div class="friend-card-header">
                                <div class="friend-card-avatar ${friend.avatar ? 'has-image' : ''}" ${friend.avatar ? `style=\"background-image:url(${friend.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;\"` : ''}>${friend.avatar ? '' : friend.username.charAt(0).toUpperCase()}</div>
                                <div class="friend-card-info">
                                    <div class="friend-card-username">${friend.username}</div>
                                    <div class="friend-card-status">Online</div>
                                </div>
                                <button class="friend-action-btn" onclick="event.stopPropagation(); startDMFromFriend('${friend.id}', '${friend.username}')">Message</button>
                            </div>
                        </div>
                    `).join('');
                } else {
                    friendsGrid.innerHTML = `
                        <div style="grid-column: 1 / -1; text-align: center; padding: 60px; color: var(--text-secondary);">
                            <h3>No friends yet</h3>
                            <p>Add some friends to get started!</p>
                            <button class="friend-action-btn primary" onclick="switchFriendsTab('add')">Add Friends</button>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading friends:', error);
            }
        }
        
        // Setup username search functionality
        function setupUsernameSearch() {
            const searchInput = document.getElementById('username-search-input');
            const resultsContainer = document.getElementById('username-search-results');
            
            // Clear previous results
            resultsContainer.innerHTML = '<div class="search-placeholder">Enter a username to find friends</div>';
            searchInput.value = '';
            
            // Set up real-time search
            searchInput.oninput = function() {
                clearTimeout(this.searchTimeout);
                this.searchTimeout = setTimeout(() => searchUsernameOnly(this.value), 300);
            };
            
            searchInput.focus();
        }
        
        // Search users by username only
        async function searchUsernameOnly(username) {
            const resultsContainer = document.getElementById('username-search-results');
            
            if (username.length < 2) {
                resultsContainer.innerHTML = '<div class="search-placeholder">Enter at least 2 characters</div>';
                return;
            }
            
            try {
                const response = await fetch(`/api/users/search?q=${encodeURIComponent(username)}`, {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                const users = await response.json();
                
                if (users.length === 0) {
                    resultsContainer.innerHTML = '<div class="search-placeholder">No users found</div>';
                    return;
                }
                
                resultsContainer.innerHTML = users.map(user => `
                    <div class="user-result-card" onclick="openUserProfile('${user.id}', '${user.username}', ${user.avatar ? `\'${user.avatar}\'` : 'null'})">
                        <div class="user-result-avatar ${user.avatar ? 'has-image' : ''}" ${user.avatar ? `style="background-image:url(${user.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;"` : ''}>${user.avatar ? '' : user.username.charAt(0).toUpperCase()}</div>
                        <div class="user-result-info">
                            <div class="user-result-username">${user.username}</div>
                            <div class="user-result-status">Click to view profile</div>
                        </div>
                        <div class="user-result-actions">
                            <button class="quick-add-btn" onclick="event.stopPropagation(); quickAddFriend('${user.id}', '${user.username}')" title="Add Friend">
                                +
                            </button>
                        </div>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Error searching users:', error);
                resultsContainer.innerHTML = '<div class="search-placeholder">Error searching users</div>';
            }
        }
        
        // Quick add friend function
        async function quickAddFriend(userId, username) {
            console.log('Quick add friend called:', userId, username);
            try {
                const response = await fetch('/api/friends/request', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ toUserId: userId })
                });
                
                console.log('Friend request response:', response.status);
                if (response.ok) {
                    const result = await response.json();
                    console.log('Friend request successful:', result);
                    showNotification(`Friend request sent to ${username}!`);
                    // Re-run search to update the UI
                    const searchInput = document.getElementById('username-search-input');
                    if (searchInput.value) {
                        searchUsernameOnly(searchInput.value);
                    }
                } else {
                    const error = await response.json();
                    console.error('Friend request failed:', error);
                    
                    // Handle specific error cases with better messages
                    if (error.error === 'Friend request already exists') {
                        showNotification(`Friend request to ${username} already pending!`, 'error');
                    } else if (error.error === 'User is already your friend') {
                        showNotification(`${username} is already your friend!`, 'error');
                    } else if (error.error === 'Cannot send friend request to yourself') {
                        showNotification(`You cannot add yourself as a friend!`, 'error');
                    } else {
                        showNotification(error.error || 'Failed to send friend request', 'error');
                    }
                }
            } catch (error) {
                console.error('Error sending friend request:', error);
                showNotification('Error sending friend request', 'error');
            }
        }
        
        // Load pending requests in grid format
        async function loadPendingRequestsMain() {
            console.log('Loading pending requests...');
            try {
                const response = await fetch('/api/friends/requests/pending', {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                console.log('Pending requests response status:', response.status);
                if (!response.ok) {
                    console.error('Failed to load pending requests:', response.status, await response.text());
                    return;
                }
                
                const requests = await response.json();
                // Update header badge and flash state
                try { await updatePendingRequestsBadgeFromList(requests); } catch {}
                console.log('Received pending requests:', requests);
                const requestsGrid = document.getElementById('pending-requests-grid');
                
                if (!requestsGrid) {
                    console.error('Pending requests grid element not found!');
                    return;
                }
                
                if (requests.length > 0) {
                    console.log('Displaying requests:', requests.length);
                    requestsGrid.innerHTML = requests.map(request => `
                        <div class="friend-card">
                            <div class="friend-card-header">
                                <div class="friend-card-avatar ${request.avatar ? 'has-image' : ''}" ${request.avatar ? `style="background-image:url(${request.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;"` : ''}>${request.avatar ? '' : request.username.charAt(0).toUpperCase()}</div>
                                <div class="friend-card-info">
                                    <div class="friend-card-username">${request.username}</div>
                                    <div class="friend-card-status">Wants to be friends</div>
                                </div>
                            </div>
                            <div class="friend-card-actions">
                                <button class="friend-action-btn primary" onclick="acceptFriendRequestMain('${request.id}')">
                                    Accept
                                </button>
                                <button class="friend-action-btn danger" onclick="declineFriendRequestMain('${request.id}')">
                                    Decline
                                </button>
                            </div>
                        </div>
                    `).join('');
                } else {
                    requestsGrid.innerHTML = `
                        <div style="grid-column: 1 / -1; text-align: center; padding: 60px; color: var(--text-secondary);">
                            <h3>No pending requests</h3>
                            <p>You don't have any friend requests right now.</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading pending requests:', error);
            }
        }

        // Update Pending Requests badge: fetch from API
        async function updatePendingRequestsBadge() {
            try {
                const response = await fetch('/api/friends/requests/pending', {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                if (!response.ok) return;
                const requests = await response.json();
                await updatePendingRequestsBadgeFromList(requests);
            } catch (e) { /* ignore */ }
        }

        // Update badge using a provided list (avoids double fetch when we already have data)
        async function updatePendingRequestsBadgeFromList(requests) {
            const btn = document.getElementById('friends-tab-pending-btn');
            const badge = document.getElementById('pending-count-badge');
            if (!btn || !badge) return;
            const count = Array.isArray(requests) ? requests.length : 0;
            if (count > 0) {
                badge.textContent = count;
                badge.style.display = 'inline-block';
                btn.classList.add('has-pending');
            } else {
                badge.textContent = '0';
                badge.style.display = 'none';
                btn.classList.remove('has-pending');
            }
        }
        
        // Accept friend request from main UI
        async function acceptFriendRequestMain(requestId) {
            try {
                const response = await fetch(`/api/friends/request/${requestId}/accept`, {
                    method: 'POST',
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                if (response.ok) {
                    showNotification('Friend request accepted!');
                    loadPendingRequestsMain();
                    updatePendingRequestsBadge();
                    if (document.getElementById('current-friends-content').classList.contains('active')) {
                        loadCurrentFriends();
                    }
                } else {
                    showNotification('Failed to accept friend request', 'error');
                }
            } catch (error) {
                console.error('Error accepting friend request:', error);
                showNotification('Error accepting friend request', 'error');
            }
        }
        
        // Decline friend request from main UI
        async function declineFriendRequestMain(requestId) {
            try {
                const response = await fetch(`/api/friends/request/${requestId}/decline`, {
                    method: 'POST',
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                if (response.ok) {
                    showNotification('Friend request declined');
                    loadPendingRequestsMain();
                    updatePendingRequestsBadge();
                } else {
                    showNotification('Failed to decline friend request', 'error');
                }
            } catch (error) {
                console.error('Error declining friend request:', error);
                showNotification('Error declining friend request', 'error');
            }
        }
        
        // Detailed user profile view
        function viewUserProfileDetailed(userId, username, avatar = null) {
            openUserProfile(userId, username, avatar);
        }
        
        // Helper functions for friend cards
        function startDMFromFriend(userId, username) {
            console.log('Starting DM with friend:', userId, username);
            
            // Check if DM already exists, if so just open it
            if (dmUsers.has(parseInt(userId))) {
                console.log('DM already exists, opening existing conversation');
                openDirectMessage(userId, username);
                return;
            }
            
            // Add to DM list first
            addToDMList({ id: parseInt(userId), username: username });
            
            // Then open the conversation
            openDirectMessage(userId, username);
        }
        
        function viewFriendProfile(userId, username) {
            viewUserProfileDetailed(userId, username);
        }
        
        function removeFriendCard(userId, username) {
            if (!confirm(`Remove ${username} from your friends?`)) return;
            
            removeFriendById(userId).then(() => {
                loadCurrentFriends(); // Refresh the friends grid
            });
        }
        
        // Remove friend by ID
        async function removeFriendById(userId) {
            try {
                const response = await fetch(`/api/friends/${userId}`, {
                    method: 'DELETE',
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                if (response.ok) {
                    showNotification('Friend removed');
                    return true;
                } else {
                    showNotification('Failed to remove friend', 'error');
                    return false;
                }
            } catch (error) {
                console.error('Error removing friend:', error);
                showNotification('Error removing friend', 'error');
                return false;
            }
        }
        
        // Update the main initialization to use new friends function
        function selectFriendsButton() {
            showFriendsMain();
        }
        
        async function searchUsers() {
            const searchTerm = document.getElementById('user-search-input').value.trim();
            const resultsContainer = document.getElementById('search-results');
            
            if (searchTerm.length < 2) {
                resultsContainer.innerHTML = '<div class="search-message">Enter at least 2 characters to search</div>';
                return;
            }
            
            try {
                const response = await fetch(`/api/users/search?q=${encodeURIComponent(searchTerm)}`, {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                const users = await response.json();
                
                if (users.length === 0) {
                    resultsContainer.innerHTML = '<div class="search-message">No users found</div>';
                    return;
                }
                
                resultsContainer.innerHTML = users.map(user => `
                    <div class="user-search-result" onclick="openUserProfile('${user.id}', '${user.username}', ${user.avatar ? `\'${user.avatar}\'` : 'null'})">
                        <div class="user-avatar ${user.avatar ? 'has-image' : ''}" ${user.avatar ? `style=\"background-image:url(${user.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;\"` : ''}>${user.avatar ? '' : user.username.charAt(0).toUpperCase()}</div>
                        <div class="user-info">
                            <div class="user-name">${user.username}</div>
                            <div class="user-status">Click to view profile</div>
                        </div>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Error searching users:', error);
                resultsContainer.innerHTML = '<div class="search-message">Error searching users</div>';
            }
        }
        
        // Open user profile modal (fetches full profile incl. banner/bio/servers)
        function openUserProfile(userId, username, avatar = null) {
            // Helper to parse current logged in user id from JWT (cached after first call)
            if (typeof window.getCurrentUserId !== 'function') {
                window.getCurrentUserId = function() {
                    if (window._cachedCurrentUserId) return window._cachedCurrentUserId;
                    const token = localStorage.getItem('token');
                    if (!token || token.split('.').length !== 3) return null;
                    try {
                        const payload = JSON.parse(atob(token.split('.')[1]));
                        window._cachedCurrentUserId = payload.id || payload.userId || payload.sub || null;
                        return window._cachedCurrentUserId;
                    } catch (e) { return null; }
                }
            }
            currentProfileUser = { id: userId, username, avatar };
            const nameEl = document.getElementById('profile-username');
            const pfp = document.getElementById('profile-avatar');
            const headerEl = document.getElementById('profile-header');
            const bioWrapper = document.getElementById('profile-bio-section');
            const bioEl = document.getElementById('profile-bio');
            const serversEl = document.getElementById('profile-servers');
            const serverListEl = document.getElementById('profile-server-list');
            // Reset Add Friend button to a sane default before async status check
            const addBtn = document.getElementById('profile-add-friend-btn');
            if (addBtn) {
                addBtn.style.display = 'inline-block';
                addBtn.disabled = false;
                addBtn.textContent = 'Add Friend';
            }

            // Optimistic render while fetching
            if (nameEl) nameEl.textContent = username || '';
            if (pfp) {
                if (avatar) {
                    pfp.style.backgroundImage = `url(${avatar})`;
                    pfp.style.backgroundSize = 'cover';
                    pfp.style.backgroundPosition = 'center';
                    pfp.style.backgroundRepeat = 'no-repeat';
                    pfp.textContent = '';
                } else {
                    pfp.style.backgroundImage = '';
                    pfp.textContent = (username || '?').charAt(0).toUpperCase();
                }
            }
            if (headerEl) headerEl.style.backgroundImage = '';
            if (bioEl) bioEl.textContent = '';
            if (bioWrapper) bioWrapper.style.display = 'none';
            if (serversEl) { serversEl.style.display = 'none'; }
            if (serverListEl) serverListEl.innerHTML = '';

            document.getElementById('user-profile-modal').style.display = 'flex';
            // If viewing own profile, hide friend actions entirely
            const myId = window.getCurrentUserId();
            if (myId && String(myId) === String(userId)) {
                const footer = document.getElementById('profile-modal-actions');
                if (footer) {
                    footer.innerHTML = `
                        <button type="button" class="btn btn-secondary" onclick="hideUserProfile()">Close</button>
                    `;
                }
                if (addBtn) addBtn.style.display = 'none';
            } else {
                // Update actions (friend/message button) only for other users
                checkFriendshipStatus(userId);
            }
            // Fetch full profile
            loadAndPopulateUserProfile(userId, username, avatar);
        }

        // Open the currently logged in user's own profile from the bottom user area
        function openOwnProfile(e) {
            if (e) e.stopPropagation();
            // Ensure helper exists even if no other profile was opened yet
            if (typeof window.getCurrentUserId !== 'function') {
                window.getCurrentUserId = function() {
                    if (window._cachedCurrentUserId) return window._cachedCurrentUserId;
                    const token = localStorage.getItem('token');
                    if (!token || token.split('.').length !== 3) return null;
                    try {
                        const payload = JSON.parse(atob(token.split('.')[1]));
                        window._cachedCurrentUserId = payload.id || payload.userId || payload.sub || null;
                        return window._cachedCurrentUserId;
                    } catch { return null; }
                }
            }
            const myId = window.getCurrentUserId();
            if (!myId) return;
            // Pull current displayed username/avatar if available
            const usernameEl = document.getElementById('current-username');
            const avatarEl = document.getElementById('user-avatar');
            let username = usernameEl ? usernameEl.textContent.trim() : 'You';
            let avatar = null;
            if (avatarEl && avatarEl.style && avatarEl.style.backgroundImage) {
                const bg = avatarEl.style.backgroundImage;
                if (bg.startsWith('url(')) {
                    avatar = bg.slice(4, -1).replace(/"/g,'');
                }
            }
            console.debug('Opening own profile', { myId, username, avatar });
            openUserProfile(myId, username, avatar);
        }

        async function loadAndPopulateUserProfile(userId, fallbackUsername, fallbackAvatar) {
            try {
                const res = await fetch(`/api/users/${encodeURIComponent(userId)}/profile`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token') || ''}` }
                });
                if (!res.ok) return;
                const profile = await res.json();
                // Keep a richer local copy
                currentProfileUser = {
                    id: profile.id ?? userId,
                    username: profile.username ?? fallbackUsername,
                    avatar: profile.avatar ?? fallbackAvatar,
                    banner: profile.banner ?? null,
                    bio: profile.bio ?? ''
                };

                const nameEl = document.getElementById('profile-username');
                const pfp = document.getElementById('profile-avatar');
                const headerEl = document.getElementById('profile-header');
                const bioWrapper = document.getElementById('profile-bio-section');
                const bioEl = document.getElementById('profile-bio');
                const serversEl = document.getElementById('profile-servers');
                const serverListEl = document.getElementById('profile-server-list');

                if (nameEl) nameEl.textContent = currentProfileUser.username || '';
                if (pfp) {
                    if (currentProfileUser.avatar) {
                        pfp.style.backgroundImage = `url(${currentProfileUser.avatar})`;
                        pfp.style.backgroundSize = 'cover';
                        pfp.style.backgroundPosition = 'center';
                        pfp.style.backgroundRepeat = 'no-repeat';
                        pfp.textContent = '';
                    } else {
                        pfp.style.backgroundImage = '';
                        pfp.textContent = (currentProfileUser.username || '?').charAt(0).toUpperCase();
                    }
                }
                if (headerEl) {
                    if (currentProfileUser.banner) {
                        headerEl.style.backgroundImage = `url(${currentProfileUser.banner})`;
                        headerEl.style.backgroundSize = 'cover';
                        headerEl.style.backgroundPosition = 'center';
                        headerEl.style.backgroundRepeat = 'no-repeat';
                    } else {
                        headerEl.style.backgroundImage = '';
                    }
                }
                if (bioEl) bioEl.innerHTML = renderBio(currentProfileUser.bio || '');
                if (bioWrapper) bioWrapper.style.display = currentProfileUser.bio ? 'block' : 'none';
                if (serverListEl) {
                    serverListEl.innerHTML = '';
                    const servers = Array.isArray(profile.servers) ? profile.servers : [];
                    servers.forEach(sv => {
                        const chip = document.createElement('div');
                        chip.className = 'profile-server-chip';
                        const icon = document.createElement('div');
                        icon.className = 'profile-server-icon';
                        if (sv.icon) {
                            icon.style.backgroundImage = `url(${sv.icon})`;
                        } else {
                            icon.style.backgroundImage = '';
                            icon.textContent = (sv.name || '?').charAt(0).toUpperCase();
                        }
                        const label = document.createElement('span');
                        label.textContent = sv.name || 'Server';
                        chip.appendChild(icon);
                        chip.appendChild(label);
                        serverListEl.appendChild(chip);
                    });
                    const serversEl = document.getElementById('profile-servers');
                    if (serversEl) serversEl.style.display = servers.length ? 'block' : 'none';
                }
            } catch (e) {
                console.error('Failed to load profile', e);
            }
        }

        // Lightweight markdown-ish renderer for bios (headings, bold, italic, code, lists, links, line breaks)
        function renderBioMarkdown(src) {
            if (!src) return '';
            // Escape HTML first
            let text = src.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]||c));
            // Headings (###, ##, #) at line start
            text = text.replace(/^###\s+(.+)$/gm, '<h5 class="bio-h bio-h3">$1</h5>')
                       .replace(/^##\s+(.+)$/gm, '<h4 class="bio-h bio-h2">$1</h4>')
                       .replace(/^#\s+(.+)$/gm, '<h3 class="bio-h bio-h1">$1</h3>');
            // Bold **text**
            text = text.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            // Italic *text* (avoid bold overlap)
            text = text.replace(/(^|[^*])\*(?!\*)([^\n*][^\n]*?)\*(?!\*)/g, '$1<em>$2</em>');
            // Inline code `code`
            text = text.replace(/`([^`]{1,60})`/g, '<code class="bio-code">$1</code>');
            // Links [text](url)
            text = text.replace(/\[([^\]]{1,60})\]\((https?:\/\/[^)\s]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer" class="bio-link">$1</a>');
            // Unordered list lines starting with - or *
            if (/^(?:-|\*)\s+/m.test(text)) {
                text = text.replace(/(?:^|\n)(?:-|\*)\s+.*(?:\n(?:-|\*)\s+.*)*/g, block => {
                    const items = block.trim().split(/\n/).map(l => l.replace(/^(?:-|\*)\s+/, ''));
                    return '\n<ul class="bio-list">' + items.map(i => '<li>' + i + '</li>').join('') + '</ul>';
                });
            }
            // Paragraph & line breaks: collapse multiple blank lines to single
            text = text.replace(/\n{3,}/g, '\n\n');
            // Convert double newlines to paragraph breaks
            const parts = text.split(/\n\n/).map(p => p.includes('<h') || p.startsWith('<ul') ? p : '<p class="bio-p">' + p.replace(/\n/g,'<br>') + '</p>');
            return parts.join('');
        }
        // Sanitize HTML bio (keep limited inline styles for color, background, size, align)
        function sanitizeBioHtml(html){
            if(!html) return '';
            // Convert <font color> to <span style="color:..."> before stripping
            html = html.replace(/<font([^>]*)color=("|')?([^"'>]+)\2?([^>]*)>/gi, '<span style="color:$3">');
            html = html.replace(/<font[^>]*>/gi,'<span>');
            html = html.replace(/<\/font>/gi,'</span>');
            // Remove scripts/styles entirely
            html = html.replace(/<script[\s\S]*?<\/script>/gi,'').replace(/<style[\s\S]*?<\/style>/gi,'');
            const allowedTags = new Set(['B','STRONG','I','EM','CODE','UL','OL','LI','BR','SPAN','H3','H4','H5','P']);
            const temp = document.createElement('div');
            temp.innerHTML = html;
            const walker = document.createTreeWalker(temp, NodeFilter.SHOW_ELEMENT, null);
            const toRemove = [];
            while(walker.nextNode()){
                const el = walker.currentNode;
                if(!allowedTags.has(el.tagName)){
                    // Replace disallowed block with its text content
                    const span = document.createTextNode(el.textContent);
                    el.parentNode.replaceChild(span, el);
                    continue;
                }
                // Clean attributes
                [...el.attributes].forEach(attr=>{
                    if(attr.name.startsWith('on')) el.removeAttribute(attr.name);
                    if(attr.name === 'style'){
                        const safeStyles = [];
                        attr.value.split(';').forEach(rule=>{
                            const r = rule.trim(); if(!r) return;
                            if(/^(font-size|text-align)\s*:/i.test(r)) safeStyles.push(r); // color/background removed
                        });
                        if(safeStyles.length) el.setAttribute('style', safeStyles.join('; ')); else el.removeAttribute('style');
                    } else if(attr.name !== 'style') {
                        // Remove all non-style attributes (including class) to avoid unexpected styling injection
                        el.removeAttribute(attr.name);
                    }
                });
                // Normalize heading tags (we use h3-h5 for sizes)
                if(/^H[1-2]$/.test(el.tagName)){
                    el.outerHTML = '<h3>'+el.textContent+'</h3>';
                }
                if(el.tagName === 'DIV'){
                    const p = document.createElement('p');
                    p.innerHTML = el.innerHTML; el.parentNode.replaceChild(p, el);
                }
            }
            // Remove empty spans/headings
            temp.querySelectorAll('span,h3,h4,h5,p').forEach(n=>{ if(!n.textContent.trim()) n.remove(); });
            return temp.innerHTML.trim();
        }
        // General renderer that decides whether stored bio is HTML or markdown-ish text
        function renderBio(bio){
            if(!bio) return '';
            if(bio.includes('<')){ return sanitizeBioHtml(bio); }
            return renderBioMarkdown(bio);
        }
        
        // Check friendship status and update profile buttons
        async function checkFriendshipStatus(userId) {
            try {
                // Early exit if self profile
                if (typeof window.getCurrentUserId === 'function') {
                    const myId = window.getCurrentUserId();
                    if (myId && String(myId) === String(userId)) {
                        const footer = document.getElementById('profile-modal-actions');
                        if (footer) {
                            footer.innerHTML = `
                                <button type="button" class="btn btn-secondary" onclick="hideUserProfile()">Close</button>
                            `;
                        }
                        const actionsDiv = document.querySelector('.profile-actions');
                        if (actionsDiv) actionsDiv.innerHTML = '';
                        const addBtn = document.getElementById('profile-add-friend-btn');
                        if (addBtn) addBtn.style.display = 'none';
                        return; // do not call backend for self
                    }
                }
                const response = await fetch('/api/friends/status/' + userId, {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                const status = await response.json();
                const actionsDiv = document.querySelector('.profile-actions');
                if (actionsDiv) {
                    // If a dedicated actions container exists, render action set (no Send Message in full profile)
                    if (status.areFriends) {
                        actionsDiv.innerHTML = `
                            <button class="profile-btn remove-friend" onclick="removeFriendFromProfile()">Remove Friend</button>
                        `;
                    } else if (status.pendingRequest) {
                        actionsDiv.innerHTML = `
                            <button class="profile-btn pending" disabled>Friend Request Pending</button>
                        `;
                    } else {
                        actionsDiv.innerHTML = `
                            <button class="profile-btn add-friend" onclick="sendFriendRequestFromProfile()">Add Friend</button>
                        `;
                    }
                } else {
                    // Fallback: render into the sticky footer actions row
                    const footer = document.getElementById('profile-modal-actions');
                    if (footer) {
                        if (status.areFriends) {
                            footer.innerHTML = `
                                <button type="button" class="btn btn-secondary" onclick="hideUserProfile()">Close</button>
                                <button type="button" class="btn btn-secondary" onclick="removeFriendFromProfile()">Remove Friend</button>
                            `;
                        } else if (status.pendingRequest) {
                            footer.innerHTML = `
                                <button type="button" class="btn btn-secondary" onclick="hideUserProfile()">Close</button>
                                <button type="button" class="btn btn-primary" id="profile-add-friend-btn" disabled>Friend Request Pending</button>
                            `;
                        } else {
                            footer.innerHTML = `
                                <button type="button" class="btn btn-secondary" onclick="hideUserProfile()">Close</button>
                                <button type="button" class="btn btn-primary" id="profile-add-friend-btn" onclick="sendFriendRequestToProfile()">Add Friend</button>
                            `;
                        }
                    } else {
                        // Last resort: toggle only the Add Friend button
                        const addBtn = document.getElementById('profile-add-friend-btn');
                        if (addBtn) {
                            if (status.areFriends) {
                                addBtn.style.display = 'none';
                            } else if (status.pendingRequest) {
                                addBtn.style.display = 'inline-block';
                                addBtn.disabled = true;
                                addBtn.textContent = 'Friend Request Pending';
                            } else {
                                addBtn.style.display = 'inline-block';
                                addBtn.disabled = false;
                                addBtn.textContent = 'Add Friend';
                            }
                        }
                    }
                }
                
            } catch (error) {
                console.error('Error checking friendship status:', error);
            }
        }
        
        // Send friend request from profile
        async function sendFriendRequestFromProfile() {
            if (!currentProfileUser) return;
            
            try {
                const response = await fetch('/api/friends/request', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        Authorization: `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({ toUserId: currentProfileUser.id })
                });
                
                if (response.ok) {
                    showNotification('Friend request sent!');
                    checkFriendshipStatus(currentProfileUser.id);
                } else {
                    const error = await response.json();
                    showNotification(error.error || 'Failed to send friend request', 'error');
                }
            } catch (error) {
                console.error('Error sending friend request:', error);
                showNotification('Error sending friend request', 'error');
            }
        }
        
        // Remove friend from profile
        async function removeFriendFromProfile() {
            if (!currentProfileUser) return;
            
            if (!confirm(`Remove ${currentProfileUser.username} from your friends?`)) return;
            
            try {
                const response = await fetch(`/api/friends/${currentProfileUser.id}`, {
                    method: 'DELETE',
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                if (response.ok) {
                    showNotification('Friend removed');
                    checkFriendshipStatus(currentProfileUser.id);
                    loadFriends(); // Refresh friends list
                } else {
                    showNotification('Failed to remove friend', 'error');
                }
            } catch (error) {
                console.error('Error removing friend:', error);
                showNotification('Error removing friend', 'error');
            }
        }
        
        // Start direct message
        function startDirectMessage() {
            if (!currentProfileUser) return;
            
            // Switch to DM view
            currentView = 'dm';
            currentChannel = null;
            currentServer = null;
            
            // Update UI
            document.getElementById('friends-section').style.display = 'block';
            document.getElementById('server-channels-section').style.display = 'none';
            document.getElementById('message-input-area').style.display = 'block';
            document.querySelector('.server-icon.active')?.classList.remove('active');
            document.getElementById('friends-btn').classList.add('active');
            document.getElementById('current-server-name').textContent = `Direct Message with ${currentProfileUser.username}`;
            
            // Close profile modal
            closeUserProfile();
            
            // Load DM messages
            loadDirectMessages(currentProfileUser.id);
            
            // Add to DM list if not already there
            addToDMList(currentProfileUser);
        }
        
        // Close user profile modal (modal button wiring)
        function hideUserProfile() { closeUserProfile(); }
        function closeUserProfile() {
            document.getElementById('user-profile-modal').style.display = 'none';
            currentProfileUser = null;
        }

        // Modal button: send friend request
        async function sendFriendRequestToProfile() {
            await sendFriendRequestFromProfile();
        }
        
        // Show friends tab content
        function showFriendsTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.friends-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[onclick="showFriendsTab('${tab}')"]`).classList.add('active');
            
            // Hide all tab contents
            document.querySelectorAll('.friends-tab-content').forEach(content => content.style.display = 'none');
            
            // Show selected tab content
            document.getElementById(`${tab}-friends-tab`).style.display = 'block';
            
            // Load content based on tab
            if (tab === 'all') {
                loadFriends();
            } else if (tab === 'pending') {
                loadPendingRequests();
            }
        }
        
        // Load pending friend requests
        async function loadPendingRequests() {
            try {
                const response = await fetch('/api/friends/requests/pending', {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                const requests = await response.json();
                const container = document.getElementById('pending-requests-list');
                
                if (requests.length === 0) {
                    container.innerHTML = '<div class="no-friends">No pending friend requests</div>';
                    return;
                }
                
                container.innerHTML = requests.map(request => `
                    <div class="friend-item">
                        <div class="friend-avatar">${request.username.charAt(0).toUpperCase()}</div>
                        <div class="friend-info">
                            <div class="friend-name">${request.username}</div>
                            <div class="friend-status">Wants to be friends</div>
                        </div>
                        <div class="friend-actions">
                            <button class="friend-action-btn accept" onclick="acceptFriendRequest('${request.id}')">Accept</button>
                            <button class="friend-action-btn decline" onclick="declineFriendRequest('${request.id}')">Decline</button>
                        </div>
                    </div>
                `).join('');
                
            } catch (error) {
                console.error('Error loading pending requests:', error);
            }
        }
        
        // Accept friend request
        async function acceptFriendRequest(requestId) {
            try {
                const response = await fetch(`/api/friends/request/${requestId}/accept`, {
                    method: 'POST',
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                if (response.ok) {
                    showNotification('Friend request accepted!');
                    loadPendingRequests();
                    loadFriends();
                } else {
                    showNotification('Failed to accept friend request', 'error');
                }
            } catch (error) {
                console.error('Error accepting friend request:', error);
                showNotification('Error accepting friend request', 'error');
            }
        }
        
        // Decline friend request
        async function declineFriendRequest(requestId) {
            try {
                const response = await fetch(`/api/friends/request/${requestId}/decline`, {
                    method: 'POST',
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                if (response.ok) {
                    showNotification('Friend request declined');
                    loadPendingRequests();
                } else {
                    showNotification('Failed to decline friend request', 'error');
                }
            } catch (error) {
                console.error('Error declining friend request:', error);
                showNotification('Error declining friend request', 'error');
            }
        }

        // Direct Messages functionality
        let directMessages = new Map(); // userId -> messages array
        let dmUsers = new Map(); // userId -> user info

        // Deterministic per-user avatar colors for DMs
        function stringHash(input) {
            try {
                const str = String(input || '');
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    hash = (hash << 5) - hash + str.charCodeAt(i);
                    hash |= 0; // Convert to 32bit integer
                }
                return Math.abs(hash);
            } catch { return 0; }
        }

        // Curated, brand-friendly gradient pairs (no yellow/green)
        const AVATAR_GRADIENTS = [
            ['#ff4d6d', '#f03e7e'], // vibrant pink
            ['#ff6b6b', '#f06595'], // warm coral/pink
            ['#e64980', '#be4bdb'], // magenta -> purple
            ['#ae3ec9', '#7048e8'], // purple -> violet
            ['#845ef7', '#5c7cfa'], // violet -> indigo
            ['#4dabf7', '#228be6'], // light blue -> blue
            ['#3bc9db', '#22b8cf'], // cyan family (avoids green/yellow)
            ['#ffa8a8', '#ff8787'], // soft red
            ['#fa5252', '#e03131'], // red
            ['#ff2975', '#ff2241'], // brand magenta -> crimson
        ];

        function getUserAvatarGradient(user) {
            const key = (user && (user.id ?? user.username)) ?? '0';
            const hash = stringHash(key);
            const idx = hash % AVATAR_GRADIENTS.length;
            const [c1, c2] = AVATAR_GRADIENTS[idx];
            return `linear-gradient(135deg, ${c1}, ${c2})`;
        }

        // Load direct messages with a user
        async function loadDirectMessages(userId) {
            console.log('Loading direct messages with user:', userId);
            try {
                const response = await fetch(`/api/messages/dm/${userId}`, {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                console.log('DM response status:', response.status);
                if (response.ok) {
                    const messages = await response.json();
                    console.log('Received DM messages:', messages);
                    directMessages.set(parseInt(userId), messages);
                    await displayMessages(messages);
                    updateDMList(); // Refresh DM list with latest message preview
                } else {
                    console.log('No DM messages found, starting fresh conversation');
                    directMessages.set(parseInt(userId), []);
                    await displayMessages([]);
                }
            } catch (error) {
                console.error('Error loading direct messages:', error);
                directMessages.set(parseInt(userId), []);
                await displayMessages([]);
            }
        }
        
        // Add user to DM list
        function addToDMList(user) {
            console.log('Adding user to DM list:', user);
            // Check if user already exists to prevent duplicates
            if (dmUsers.has(user.id)) {
                console.log('User already in DM list, skipping duplicate');
                return;
            }
            dmUsers.set(user.id, user);
            updateDMList();
            console.log('DM users list:', Array.from(dmUsers.values()));
        }
        
        // Ensure correct sidebar highlighting
        function ensureCorrectHighlighting() {
            if (currentView === 'dm' && currentDMUser) {
                const targetDMItem = document.querySelector(`[data-user-id="${currentDMUser.id}"]`);
                
                // Only update if highlighting is incorrect
                if (targetDMItem && !targetDMItem.classList.contains('active')) {
                    // Remove all active states
                    document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                    document.querySelectorAll('.dm-item').forEach(item => item.classList.remove('active'));
                    
                    // Highlight the current DM conversation
                    targetDMItem.classList.add('active');
                }
            } else if (currentView === 'friends') {
                const friendsBtn = document.querySelector('[data-view="friends"]');
                
                // Only update if highlighting is incorrect
                if (friendsBtn && !friendsBtn.classList.contains('active')) {
                    document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
                    document.querySelectorAll('.dm-item').forEach(item => item.classList.remove('active'));
                    friendsBtn.classList.add('active');
                }
            }
        }
        
        // Get last message preview for DM list
        function getLastMessagePreview(userId) {
            const uid = parseInt(userId);
            const userMessages = directMessages.get(uid);
            if (userMessages && userMessages.length > 0) {
                const lastMessage = userMessages[userMessages.length - 1];
                const preview = lastMessage.text || lastMessage.content || 'Image';
                return preview.length > 30 ? preview.substring(0, 30) + '...' : preview;
            }
            // Fallback to cached conversation metadata (loaded from /api/messages/conversations)
            const dmMeta = dmUsers.get(uid);
            if (dmMeta && dmMeta.lastMessage) {
                const preview = dmMeta.lastMessage || 'Image';
                return preview.length > 30 ? preview.substring(0, 30) + '...' : preview;
            }
            return 'Click to start conversation';
        }
        
        // Update DM list display
        function updateDMList() {
            const dmList = document.getElementById('dm-conversations');
            
            // Safety check - element might not exist
            if (!dmList) {
                console.log('DM list element not found - skipping update');
                return;
            }
            
            if (dmUsers.size === 0) {
                dmList.innerHTML = '<div class="no-dms">No direct messages yet</div>';
                return;
            }
            
            // Check if we need to regenerate the entire list or just update previews
            const existingItems = dmList.querySelectorAll('.dm-item');
            const currentUserIds = Array.from(dmUsers.keys());
            const existingUserIds = Array.from(existingItems).map(item => parseInt(item.dataset.userId));
            
            // If user list changed, regenerate entire list
            if (currentUserIds.length !== existingUserIds.length || 
                !currentUserIds.every(id => existingUserIds.includes(id))) {
                
                dmList.innerHTML = Array.from(dmUsers.values()).map(user => {
                    const initial = user.username ? user.username.charAt(0).toUpperCase() : '?';
                    if (user.avatar) {
                        return `
                        <div class="dm-item" onclick="openDirectMessage('${user.id}', '${user.username}')" data-user-id="${user.id}">
                            <div class="dm-avatar has-image" style="background-image:url(${user.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;"></div>
                            <div class="dm-info">
                                <div class="dm-username">${user.username}</div>
                                <div class="dm-last-message">${getLastMessagePreview(user.id)}</div>
                            </div>
                        </div>`;
                    } else {
                        const bg = getUserAvatarGradient(user);
                        return `
                        <div class="dm-item" onclick="openDirectMessage('${user.id}', '${user.username}')" data-user-id="${user.id}">
                            <div class="dm-avatar" style="background: ${bg}">${initial}</div>
                            <div class="dm-info">
                                <div class="dm-username">${user.username}</div>
                                <div class="dm-last-message">${getLastMessagePreview(user.id)}</div>
                            </div>
                        </div>`;
                    }
                }).join('');
                
                // Restore highlighting after regeneration
                setTimeout(() => ensureCorrectHighlighting(), 10);
            } else {
                // Just update message previews without regenerating HTML
                existingItems.forEach(item => {
                    const userId = parseInt(item.dataset.userId);
                    const messageElement = item.querySelector('.dm-last-message');
                    if (messageElement) {
                        messageElement.textContent = getLastMessagePreview(userId);
                    }
                    // Ensure avatar reflects user avatar or gradient
                    const avatarEl = item.querySelector('.dm-avatar');
                    const user = dmUsers.get(userId);
                    if (avatarEl && user) {
                        if (user.avatar) {
                            avatarEl.classList.add('has-image');
                            avatarEl.style.backgroundImage = `url(${user.avatar})`;
                            avatarEl.style.backgroundSize = 'cover';
                            avatarEl.style.backgroundPosition = 'center';
                            avatarEl.style.backgroundRepeat = 'no-repeat';
                            avatarEl.textContent = '';
                        } else {
                            avatarEl.classList.remove('has-image');
                            avatarEl.style.backgroundImage = '';
                            avatarEl.style.background = getUserAvatarGradient(user);
                            const initial = user.username ? user.username.charAt(0).toUpperCase() : '?';
                            avatarEl.textContent = initial;
                        }
                    }
                });
            }
        }
        
        // Open direct message conversation
    function openDirectMessage(userId, username) {
            console.log('Opening DM with:', userId, username);
            currentView = 'dm';
            currentChannel = null;
            currentServer = null;
            const dmUserObj = dmUsers.get(parseInt(userId));
            currentDMUser = { id: parseInt(userId), username: username, avatar: dmUserObj?.avatar || null };
            
            // Reset chat area state to prevent DM area from inheriting expanded width
            const chatArea = document.getElementById('chat-area');
            chatArea.classList.add('no-transition');
            chatArea.classList.remove('expanded');
            
            // Update UI
            document.getElementById('friends-section').style.display = 'block';
            document.getElementById('server-channels-section').style.display = 'none';
            document.getElementById('message-input-area').style.display = 'block';
            document.querySelector('.server-icon.active')?.classList.remove('active');
            
            // Re-enable transitions after DOM update
            requestAnimationFrame(() => {
                chatArea.classList.remove('no-transition');
            });
            
            // Activate friends section in sidebar, but not the Friends button itself when in DM
            document.querySelectorAll('.channel-item').forEach(item => item.classList.remove('active'));
            // Don't highlight the Friends button when in a specific DM conversation
            
            // Highlight current DM conversation immediately
            document.querySelectorAll('.dm-item').forEach(item => item.classList.remove('active'));
            document.querySelector(`[data-user-id="${userId}"]`)?.classList.add('active');
            
            // Update header to show DM conversation
            document.getElementById('current-server-name').textContent = `Direct Message with ${username}`;
            document.getElementById('header-icon').textContent = '💬';
            document.getElementById('current-channel-name').textContent = username;
            document.getElementById('current-channel-info').textContent = 'Direct Message';
            
            // Hide friends main area and show chat area
            document.getElementById('friends-main-area').style.display = 'none';
            document.getElementById('chat-area').style.display = 'flex';
            document.getElementById('messages-container').style.display = 'block';
            
            // Clear messages and load DM messages
            document.getElementById('messages-container').innerHTML = '';
            loadDirectMessages(userId);
            
            // Ensure DM highlighting persists after async operations
            setTimeout(() => {
                ensureCorrectHighlighting();
            }, 10);
        }

        // Load DM conversations list
        async function loadDMConversations() {
            try {
                const response = await fetch('/api/messages/conversations', {
                    headers: { Authorization: `Bearer ${localStorage.getItem('token')}` }
                });
                
                if (response.ok) {
                    const conversations = await response.json();
                    conversations.forEach(conv => {
                        dmUsers.set(conv.id, {
                            id: conv.id,
                            username: conv.username,
                            avatar: conv.avatar || null,
                            lastMessage: conv.lastMessage || null,
                            lastMessageTime: conv.lastMessageTime || null
                        });
                    });
                    updateDMList();
                }
            } catch (error) {
                console.error('Error loading DM conversations:', error);
            }
        }

        // Click outside modal to close
        window.onclick = function(event) {
            const serverModal = document.getElementById('server-modal');
            const addFriendModal = document.getElementById('add-friend-modal');
            const inviteModal = document.getElementById('server-invite-modal');
            const imageModal = document.getElementById('image-modal');
            const profileModal = document.getElementById('user-profile-modal');
            
            if (event.target === serverModal) {
                hideServerModal();
            }
            if (event.target === addFriendModal) {
                hideAddFriendModal();
            }
            if (event.target === inviteModal) {
                hideInviteModal();
            }
            if (event.target === imageModal) {
                closeImageModal();
            }
            if (event.target === profileModal) {
                closeUserProfile();
            }
        }

        // Channel Management Functions
        function showCreateChannelModal() {
            if (!currentServer) return;
            document.getElementById('create-channel-modal').style.display = 'block';
        }

        function hideCreateChannelModal() {
            document.getElementById('create-channel-modal').style.display = 'none';
            document.getElementById('channel-name').value = '';
            document.getElementById('channel-description').value = '';
        }

        async function createChannel(event) {
            event.preventDefault();
            
            const name = document.getElementById('channel-name').value.trim();
            const description = document.getElementById('channel-description').value.trim();
            
            if (!name || !currentServer) return;
            
            try {
                const response = await fetch(`/api/servers/${currentServer.id}/channels`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify({
                        name: name.toLowerCase().replace(/[^a-z0-9-]/g, ''),
                        description
                    })
                });

                if (response.ok) {
                    hideCreateChannelModal();
                    await loadServerChannels(currentServer.id);
                    showNotification('Channel created successfully!', 'success');
                } else {
                    const error = await response.json();
                    alert(error.message || 'Failed to create channel');
                }
            } catch (error) {
                console.error('Error creating channel:', error);
                alert('Failed to create channel. Please try again.');
            }
        }

        // ===== Account Settings (Profile) =====
        function openAccountSettings() {
            const modal = document.getElementById('account-settings-modal');
            const nameInput = document.getElementById('account-username-input');
            const bioInput = document.getElementById('account-bio-input');
            const bioEditor = document.getElementById('account-bio-editor');
            const avatarPrev = document.getElementById('account-avatar-preview');
            const bannerPrev = document.getElementById('account-banner-preview');
            if (nameInput && currentUser) nameInput.value = currentUser.username || '';
            if (bioEditor && currentUser) {
                // Convert stored plain/markdown text to simple HTML (reuse renderer but strip outer paragraphs for editing)
                const rawBio = (currentUser.bio || '').replace(/\r\n?/g,'\n');
                if(rawBio.includes('<')){
                    bioEditor.innerHTML = sanitizeBioHtml(rawBio);
                    bioInput.value = sanitizeBioHtml(rawBio);
                } else {
                    const rendered = renderBioMarkdown(rawBio);
                    if (!rendered.trim()) bioEditor.innerHTML = '';
                    else bioEditor.innerHTML = rendered
                        .replace(/<p class=\"bio-p\">([\s\S]*?)<\/p>/g, '$1')
                        .replace(/<h[3-5][^>]*>/g, '')
                        .replace(/<\/h[3-5]>/g,'');
                    bioInput.value = rawBio;
                }
                syncBioHidden();
            }
            if (avatarPrev) {
                avatarPrev.textContent = (currentUser?.username || 'A').charAt(0).toUpperCase();
                if (currentUser?.avatar) {
                    avatarPrev.style.backgroundImage = `url(${currentUser.avatar})`;
                    avatarPrev.style.backgroundSize = 'cover';
                    avatarPrev.style.backgroundPosition = 'center';
                    avatarPrev.style.backgroundRepeat = 'no-repeat';
                    avatarPrev.style.backgroundColor = 'transparent';
                    // Ensure no initial letter overlays the image
                    avatarPrev.textContent = '';
                } else {
                    avatarPrev.style.backgroundImage = '';
                    avatarPrev.style.background = 'var(--brand-gradient)';
                }
            }
            if (bannerPrev) {
                if (currentUser?.banner) {
                    bannerPrev.style.backgroundImage = `url(${currentUser.banner})`;
                    bannerPrev.style.backgroundSize = 'cover';
                    bannerPrev.style.backgroundPosition = 'center';
                    bannerPrev.style.backgroundRepeat = 'no-repeat';
                    bannerPrev.textContent = '';
                } else {
                    bannerPrev.style.backgroundImage = '';
                    bannerPrev.textContent = 'Click to set banner';
                }
            }
            modal.style.display = 'block';
            document.body.style.overflow = 'hidden';
            showAccountSection('profile');
            // Defer compression to next frame so layout metrics are accurate
            requestAnimationFrame(autoCompressBioToolbar);
        }

        function closeAccountSettings() {
            document.getElementById('account-settings-modal').style.display = 'none';
            document.body.style.overflow = '';
        }

        function showAccountSection(id) {
            const sections = ['profile','voice'];
            sections.forEach(sec => {
                const el = document.getElementById(`account-section-${sec}`);
                if (el) el.style.display = (sec === id) ? 'block' : 'none';
            });
        }

        function triggerAccountAvatarPick() {
            const input = document.getElementById('account-avatar-file');
            if (!input) return;
            // Reset value so selecting the same file triggers change
            input.value = '';
            input.onchange = (e) => handleAccountAvatarFile(e);
            input.click();
        }

        function triggerAccountBannerPick() {
            const input = document.getElementById('account-banner-file');
            if (!input) return;
            input.value = '';
            input.onchange = (e) => {
                const file = e.target.files && e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const bannerPrev = document.getElementById('account-banner-preview');
                    const dataUrl = ev.target.result;
                    bannerPrev.style.backgroundImage = `url(${dataUrl})`;
                    bannerPrev.style.backgroundSize = 'cover';
                    bannerPrev.style.backgroundPosition = 'center';
                    bannerPrev.style.backgroundRepeat = 'no-repeat';
                    bannerPrev.textContent = '';
                    bannerPrev.dataset.previewBannerUrl = dataUrl;
                };
                reader.readAsDataURL(file);
                setTimeout(() => { try { input.blur(); } catch {} }, 0);
            };
            input.click();
        }

        function handleAccountAvatarFile(event) {
            const input = event.target;
            const file = input.files && input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                // Open the existing cropper
                openIconCropper(e.target.result);
                // Change header to reflect avatar editing
                const cropHeaderEl = document.querySelector('#icon-cropper-modal .cropper-header');
                const previousHeader = cropHeaderEl ? cropHeaderEl.textContent : null;
                if (cropHeaderEl) cropHeaderEl.textContent = 'Adjust Avatar';
                const original = applyIconCrop;
                window.applyIconCrop = function() {
                    // Custom crop for account avatar without touching server icon
                    const size = 256;
                    const canvas = document.createElement('canvas');
                    canvas.width = size; canvas.height = size;
                    const ctx = canvas.getContext('2d');

                    // Clip circle
                    ctx.clearRect(0, 0, size, size);
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
                    ctx.closePath();
                    ctx.clip();

                    // Compute image draw params mirroring cropper
                    const vRect = cropperState.viewportEl.getBoundingClientRect();
                    const imgEl = cropperState.imgEl;
                    const displayedWidth = imgEl.getBoundingClientRect().width;
                    const displayedHeight = imgEl.getBoundingClientRect().height;
                    const scaleRatioX = size / vRect.width;
                    const scaleRatioY = size / vRect.height;
                    const imgLeftInViewport = (vRect.width - displayedWidth) / 2 + cropperState.pos.x;
                    const imgTopInViewport = (vRect.height - displayedHeight) / 2 + cropperState.pos.y;

                    ctx.drawImage(
                        imgEl,
                        imgLeftInViewport * scaleRatioX,
                        imgTopInViewport * scaleRatioY,
                        displayedWidth * scaleRatioX,
                        displayedHeight * scaleRatioY
                    );
                    ctx.restore();
                    const dataUrl = canvas.toDataURL('image/png');

                    const avatarPrev = document.getElementById('account-avatar-preview');
                    avatarPrev.style.backgroundImage = `url(${dataUrl})`;
                    avatarPrev.style.backgroundSize = 'cover';
                    avatarPrev.style.backgroundPosition = 'center';
                    avatarPrev.style.backgroundRepeat = 'no-repeat';
                    avatarPrev.style.backgroundColor = 'transparent';
                    avatarPrev.textContent = '';
                    avatarPrev.dataset.previewDataUrl = dataUrl;

                    hideIconCropper();
                    // Restore header text
                    if (cropHeaderEl && previousHeader) cropHeaderEl.textContent = previousHeader;
                    window.applyIconCrop = original; // restore
                }
            };
            reader.readAsDataURL(file);
            // Prevent reopening picker due to stray focus; clear or blur
            setTimeout(() => { try { input.blur(); } catch {} }, 0);
        }

        function clearAccountAvatar() {
            const avatarPrev = document.getElementById('account-avatar-preview');
            if (!avatarPrev) return;
            avatarPrev.style.backgroundImage = '';
            avatarPrev.style.background = 'var(--brand-gradient)';
            avatarPrev.textContent = (currentUser?.username || 'A').charAt(0).toUpperCase();
            avatarPrev.dataset.previewDataUrl = '';
        }

        function clearAccountBanner() {
            const bannerPrev = document.getElementById('account-banner-preview');
            if (!bannerPrev) return;
            bannerPrev.style.backgroundImage = '';
            bannerPrev.textContent = 'Click to set banner';
            bannerPrev.dataset.previewBannerUrl = '';
        }

    async function saveAccountProfile(event) {
            event.preventDefault();
            try {
                const name = document.getElementById('account-username-input').value.trim();
                // Pull HTML from editor, sanitize & compress to storage format
                const editor = document.getElementById('account-bio-editor');
                const bioRawHtml = editor ? editor.innerHTML : '';
                const bio = sanitizeBioHtml(bioRawHtml).slice(0,1000);
                const avatarPrev = document.getElementById('account-avatar-preview');
                const previewDataUrl = avatarPrev?.dataset?.previewDataUrl;
        const bannerPrev = document.getElementById('account-banner-preview');
        const bannerDataUrl = bannerPrev?.dataset?.previewBannerUrl;
                const body = {};
                if (name && name !== currentUser.username) body.username = name;
                if (typeof bio !== 'undefined' && bio !== (currentUser.bio || '')) body.bio = bio;
                if (typeof previewDataUrl !== 'undefined') body.avatar = previewDataUrl || null;
        if (typeof bannerDataUrl !== 'undefined') body.banner = bannerDataUrl || null;

                const resp = await fetch('/api/users/me', {
                    method: 'PUT',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    },
                    body: JSON.stringify(body)
                });
                const data = await resp.json().catch(() => ({}));
                if (!resp.ok) {
                    showNotification(data.error || 'Failed to update profile', 'error');
                    return false;
                }
                currentUser.username = data.user?.username ?? currentUser.username;
                currentUser.avatar = data.user?.avatar ?? currentUser.avatar ?? null;
                currentUser.bio = data.user?.bio ?? currentUser.bio ?? '';
                currentUser.banner = data.user?.banner ?? currentUser.banner ?? null;
                document.getElementById('current-username').textContent = currentUser.username;
                const ua = document.getElementById('user-avatar');
                if (ua) {
                    if (currentUser.avatar) {
                        ua.style.backgroundImage = `url(${currentUser.avatar})`;
                        ua.style.backgroundSize = 'cover';
                        ua.style.backgroundPosition = 'center';
                        ua.style.backgroundRepeat = 'no-repeat';
                        ua.style.backgroundColor = 'transparent';
                        ua.textContent = '';
                    } else {
                        ua.style.backgroundImage = '';
                        ua.style.background = 'var(--brand-gradient)';
                        ua.textContent = currentUser.username.charAt(0).toUpperCase();
                    }
                }
                // Update DM list cache for self (if present) and rerender
                try {
                    if (dmUsers.has(parseInt(currentUser.id))) {
                        const self = dmUsers.get(parseInt(currentUser.id));
                        self.username = currentUser.username;
                        self.avatar = currentUser.avatar || null;
                        dmUsers.set(parseInt(currentUser.id), self);
                    }
                    updateDMList();
                } catch {}
                // Best-effort: refresh friends grid and pending list if visible
                try {
                    if (document.getElementById('current-friends-content')?.classList?.contains('active')) {
                        loadCurrentFriends();
                    }
                    if (document.getElementById('pending-requests-content')?.classList?.contains('active')) {
                        loadPendingRequestsMain();
                    }
                } catch {}
                // Best-effort: refresh members list in server settings if open
                try {
                    if (document.getElementById('server-settings-modal')?.style?.display === 'block' && currentServer) {
                        loadServerMembersForSettings();
                    }
                } catch {}
                showNotification('Profile updated');
                closeAccountSettings();
                return true;
            } catch (e) {
                console.error('saveAccountProfile error:', e);
                showNotification('Failed to update profile', 'error');
                return false;
            }
        }

        // ===== Bio Editor Helpers =====
        // --- Bio Editor Helpers with selection preservation ---
        let bioSavedRange = null;
        function bioSaveSelection(){
            const sel = window.getSelection();
            if (sel && sel.rangeCount > 0) bioSavedRange = sel.getRangeAt(0);
        }
        function bioRestoreSelection(){
            if (bioSavedRange) {
                const sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(bioSavedRange);
            }
        }
        document.getElementById('account-bio-editor').addEventListener('mouseup', bioSaveSelection);
        document.getElementById('account-bio-editor').addEventListener('keyup', bioSaveSelection);
        function bioExec(cmd, val=null){ bioRestoreSelection(); document.execCommand(cmd,false,val); syncBioHidden(); bioSaveSelection(); }
        function bioApplyHeading(level){ bioRestoreSelection(); document.execCommand('formatBlock', false, 'h'+level); syncBioHidden(); bioSaveSelection(); }
        function bioWrap(type){ bioRestoreSelection(); if (type==='code') { document.execCommand('insertHTML', false, '<code>'+document.getSelection()+'</code>'); } syncBioHidden(); bioSaveSelection(); }
        function bioInsertList(){ bioRestoreSelection(); document.execCommand('insertUnorderedList'); syncBioHidden(); bioSaveSelection(); }
        function bioCenter(){ bioRestoreSelection(); document.execCommand('justifyCenter'); syncBioHidden(); bioSaveSelection(); }
        function bioColor(){ /* removed */ }
        function bioBg(){ /* removed */ }
        function bioFontSize(sz){ if(!sz)return; document.execCommand('fontSize', false, '4');
            // Replace <font size> with span + style for consistency
            const editor=document.getElementById('account-bio-editor');
            editor.querySelectorAll('font[size]').forEach(f=>{ const span=document.createElement('span'); span.style.fontSize=sz+'px'; span.innerHTML=f.innerHTML; f.replaceWith(span); });
            syncBioHidden(); }
        function bioClearFormatting(){ const ed=document.getElementById('account-bio-editor'); if(!ed) return; const text=ed.innerText; ed.innerHTML = text; syncBioHidden(); }
    function syncBioHidden(){ const ed=document.getElementById('account-bio-editor'); const hidden=document.getElementById('account-bio-input'); if(ed&&hidden){ hidden.value = sanitizeBioHtml(ed.innerHTML).slice(0,1000); } }
        // Keep toolbar on a single line by progressively compressing padding/font-size
        function autoCompressBioToolbar(){
            const tb = document.querySelector('.bio-editor-toolbar');
            if(!tb) return;
            tb.classList.remove('compressed-1','compressed-2','compressed-3');
            // If wrapping occurred (height > 2 * base button height), start compressing
            const fits = tb.scrollWidth <= tb.clientWidth && tb.offsetHeight < 60; // heuristic
            if (fits) return;
            tb.classList.add('compressed-1');
            if(tb.scrollWidth <= tb.clientWidth) return;
            tb.classList.add('compressed-2');
            if(tb.scrollWidth <= tb.clientWidth) return;
            tb.classList.add('compressed-3');
        }
        window.addEventListener('resize', () => { autoCompressBioToolbar(); });
        // Tab inserts spaces
        document.addEventListener('keydown', e => {
            if (e.target && e.target.id === 'account-bio-editor' && e.key === 'Tab') { e.preventDefault(); document.execCommand('insertHTML', false, '&nbsp;&nbsp;&nbsp;&nbsp;'); syncBioHidden(); }
        });
        // (Old sanitizeBioHtml replaced above with new preserving HTML) REMOVED legacy conversion

        // Members Panel Functions
        // Members panel state
        let membersPanelCollapsed = false;

        function showMembersPanel() {
            const panel = document.getElementById('members-panel');
            const toggleBtn = document.getElementById('members-toggle');
            const chatArea = document.getElementById('chat-area');
            
            // Temporarily disable transitions to prevent stretching animation
            chatArea.classList.add('no-transition');
            
            // Pre-set the state based on server preferences BEFORE showing elements
            let shouldBeCollapsed = false;
            if (currentServer && currentServer.id) {
                const serverPrefs = getServerPreferences(currentServer.id);
                shouldBeCollapsed = serverPrefs.membersPanelCollapsed;
                membersPanelCollapsed = shouldBeCollapsed;
            } else {
                membersPanelCollapsed = false;
            }
            
            // Set all classes immediately before showing to prevent visual stretching
            if (shouldBeCollapsed) {
                panel.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                chatArea.classList.add('expanded');
            } else {
                panel.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                chatArea.classList.remove('expanded');
            }
            
            // Show the elements after state is set
            panel.style.display = 'flex';
            toggleBtn.style.display = 'flex';
            
            // Re-enable transitions after the DOM has updated
            requestAnimationFrame(() => {
                chatArea.classList.remove('no-transition');
            });
            
            console.log(`Showed members panel for server ${currentServer?.id || 'unknown'} with collapsed state:`, shouldBeCollapsed);
        }

        function hideMembersPanel() {
            const panel = document.getElementById('members-panel');
            const toggleBtn = document.getElementById('members-toggle');
            const chatArea = document.getElementById('chat-area');
            
            panel.style.display = 'none';
            toggleBtn.style.display = 'none';
            
            // Reset state and clean up classes
            membersPanelCollapsed = false;
            panel.classList.remove('collapsed');
            toggleBtn.classList.remove('collapsed');
            chatArea.classList.remove('expanded', 'no-transition');
        }

        function toggleMembersPanel() {
            const panel = document.getElementById('members-panel');
            const toggleBtn = document.getElementById('members-toggle');
            const chatArea = document.getElementById('chat-area');
            
            membersPanelCollapsed = !membersPanelCollapsed;
            
            if (membersPanelCollapsed) {
                // Hide panel and expand chat area
                panel.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                chatArea.classList.add('expanded');
            } else {
                // Show panel and restore chat area
                panel.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                chatArea.classList.remove('expanded');
            }
            
            // Save the panel state for current server
            saveMembersPanelState();
        }

        // Helper functions for server-specific preferences
        function saveMembersPanelState() {
            if (currentServer && currentServer.id) {
                const serverPrefs = getServerPreferences(currentServer.id);
                serverPrefs.membersPanelCollapsed = membersPanelCollapsed;
                saveServerPreferences(currentServer.id, serverPrefs);
                console.log(`Saved members panel state for server ${currentServer.id}:`, membersPanelCollapsed);
            }
        }

        function getServerPreferences(serverId) {
            const saved = localStorage.getItem(`server_prefs_${serverId}`);
            return saved ? JSON.parse(saved) : { membersPanelCollapsed: false };
        }

        function saveServerPreferences(serverId, preferences) {
            localStorage.setItem(`server_prefs_${serverId}`, JSON.stringify(preferences));
        }

        function restoreMembersPanelState(serverId) {
            const serverPrefs = getServerPreferences(serverId);
            membersPanelCollapsed = serverPrefs.membersPanelCollapsed;
            console.log(`Restored members panel state for server ${serverId}:`, membersPanelCollapsed);
            
            const panel = document.getElementById('members-panel');
            const toggleBtn = document.getElementById('members-toggle');
            const chatArea = document.getElementById('chat-area');
            
            if (membersPanelCollapsed) {
                panel.classList.add('collapsed');
                toggleBtn.classList.add('collapsed');
                chatArea.classList.add('expanded');
            } else {
                panel.classList.remove('collapsed');
                toggleBtn.classList.remove('collapsed');
                chatArea.classList.remove('expanded');
            }
        }

        async function loadServerMembers(serverId) {
            try {
                const response = await fetch(`/api/servers/${serverId}/members`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    displayServerMembers(data.members);
                } else {
                    console.error('Failed to load server members');
                }
            } catch (error) {
                console.error('Error loading server members:', error);
            }
        }

        function displayServerMembers(members) {
            const membersList = document.getElementById('members-list');
            const membersCount = document.getElementById('members-count');
            
            membersList.innerHTML = '';
            membersCount.textContent = members.length;

            // Group members by role
            const owners = members.filter(m => m.role === 'owner');
            const admins = members.filter(m => m.role === 'admin');
            const regularMembers = members.filter(m => m.role === 'member');

            // Display owners
            if (owners.length > 0) {
                membersList.innerHTML += '<div style="padding: 8px 16px; color: #8e9297; font-size: 12px; font-weight: bold; text-transform: uppercase;">Owner</div>';
                owners.forEach(member => {
                    membersList.innerHTML += createMemberHTML(member);
                });
            }

            // Display admins (inline chips)
            if (admins.length > 0) {
                membersList.innerHTML += '<div style="padding: 8px 16px; color: #8e9297; font-size: 12px; font-weight: bold; text-transform: uppercase;">Admins</div>';
                const chips = admins.map(m => createAdminChipHTML(m)).join('');
                membersList.innerHTML += `<div class="admins-inline">${chips}</div>`;
            }

            // Display members
            if (regularMembers.length > 0) {
                membersList.innerHTML += '<div style="padding: 8px 16px; color: #8e9297; font-size: 12px; font-weight: bold; text-transform: uppercase;">Members</div>';
                regularMembers.forEach(member => {
                    membersList.innerHTML += createMemberHTML(member);
                });
            }

            // Apply role colors to right-side member names
            (async () => {
                if (currentServer) {
                    if (!currentServerMembersMap || currentServerMembersMap.size === 0 || currentServerMembersCacheServerId !== parseFloat(currentServer.id)) {
                        await loadServerMembersCache(currentServer.id);
                    }
                    const items = document.querySelectorAll('#members-list .member-item');
                    for (const item of items) {
                        const uid = item.getAttribute('data-user-id');
                        const nameEl = item.querySelector('.member-name');
                        if (uid && nameEl) {
                            await applyRoleColorToAuthorElement(nameEl, uid);
                        }
                    }
                    // Also apply role colors to admin chips names
                    const adminChips = document.querySelectorAll('#members-list .admin-chip');
                    for (const chip of adminChips) {
                        const uid = chip.getAttribute('data-user-id');
                        const nameEl = chip.querySelector('.admin-name');
                        if (uid && nameEl) {
                            await applyRoleColorToAuthorElement(nameEl, uid);
                        }
                    }
                }
            })();
        }

    function createMemberHTML(member) {
            // Try to color synchronously from caches to avoid flash
            let inlineColor = '#dcddde';
            try {
                inlineColor = getRoleColorFromCaches(member.userId);
            } catch {}
            const initial = member.username ? member.username.charAt(0).toUpperCase() : '?';
            const avatarStyle = member.avatar ? `style="background-image:url(${member.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;"` : '';
            const avatarClass = member.avatar ? 'member-avatar has-image' : 'member-avatar';
            const bg = !member.avatar ? getUserAvatarGradient({ id: member.userId, username: member.username }) : '';
            return `
                <div class="member-item" data-user-id="${member.userId}" onclick="openProfilePopover(event, ${member.userId}, '${member.username.replace(/'/g, "&#39;")}', ${member.avatar ? `\'${member.avatar}\'` : 'null'})">
                    <div class="${avatarClass}" ${avatarStyle} ${member.avatar ? '' : `style="background:${bg}"`}>${member.avatar ? '' : initial}</div>
                    <div class="member-info">
                        <div class="member-name" style="color: ${inlineColor}">${member.username}</div>
                    </div>
                </div>
            `;
        }

        function createAdminChipHTML(member) {
            let inlineColor = '#dcddde';
            try { inlineColor = getRoleColorFromCaches(member.userId); } catch {}
            const initial = member.username ? member.username.charAt(0).toUpperCase() : '?';
            const avatarStyle = member.avatar ? `style="background-image:url(${member.avatar}); background-size:cover; background-position:center; background-repeat:no-repeat;"` : '';
            const avatarClass = member.avatar ? 'admin-avatar has-image' : 'admin-avatar';
            const bg = !member.avatar ? getUserAvatarGradient({ id: member.userId, username: member.username }) : '';
            return `
                <div class="admin-chip" data-user-id="${member.userId}" onclick="openProfilePopover(event, ${member.userId}, '${member.username.replace(/'/g, "&#39;")}', ${member.avatar ? `\'${member.avatar}\'` : 'null'})" title="${member.username}">
                    <div class="${avatarClass}" ${avatarStyle} ${member.avatar ? '' : `style="background:${bg}"`}>${member.avatar ? '' : initial}</div>
                    <span class="admin-name" style="color: ${inlineColor}">${member.username}</span>
                </div>
            `;
        }

        function closeMiniProfile() {
            document.getElementById('mini-profile-modal').style.display = 'none';
        }

        function openFullProfileFromMini() {
            const name = document.getElementById('mini-profile-username')?.textContent || '';
            const avatarStyle = document.getElementById('mini-profile-avatar')?.style?.backgroundImage || '';
            const avatar = avatarStyle && avatarStyle.startsWith('url(') ? avatarStyle.slice(4, -1).replace(/"/g, '') : null;
            if (window.__miniProfileUserId) openUserProfile(window.__miniProfileUserId, name, avatar);
            closeMiniProfile();
        }

        async function openMiniProfile(userId, username, avatar = null) {
            window.__miniProfileUserId = userId;
            const modal = document.getElementById('mini-profile-modal');
            const nameEl = document.getElementById('mini-profile-username');
            const avatarEl = document.getElementById('mini-profile-avatar');
            const rolesEl = document.getElementById('mini-profile-roles');

            // Set basics
            nameEl.textContent = username || '';
            if (avatar) {
                avatarEl.style.backgroundImage = `url(${avatar})`;
                avatarEl.style.backgroundSize = 'cover';
                avatarEl.style.backgroundPosition = 'center';
                avatarEl.style.backgroundRepeat = 'no-repeat';
                avatarEl.textContent = '';
            } else {
                avatarEl.style.backgroundImage = '';
                avatarEl.textContent = (username || '?').charAt(0).toUpperCase();
            }
            rolesEl.innerHTML = '';

            // Ensure caches are ready
            try {
                if (!currentServer || !currentServer.id) throw new Error('No server');
                if (!currentServerMembersMap || currentServerMembersMap.size === 0 || currentServerMembersCacheServerId !== parseFloat(currentServer.id)) {
                    await loadServerMembersCache(currentServer.id);
                }
                const member = currentServerMembersMap.get(parseInt(userId));
                const rolesMap = serverRolesCache.get(parseFloat(currentServer.id)) || {};
                // Build role chips: if a specific roleId, show that; otherwise show derived role (owner/admin/member)
                const chips = [];
                if (member?.roleId && rolesMap[member.roleId]) {
                    const r = rolesMap[member.roleId];
                    chips.push({ name: r.name || 'Role', color: r.color || '#5865f2' });
                }
                // Always include the base role label for clarity
                if (member?.role) {
                    const baseColor = member.role === 'owner' ? '#43b581' : member.role === 'admin' ? '#7289da' : '#8e9297';
                    const pretty = member.role.charAt(0).toUpperCase() + member.role.slice(1);
                    // Avoid duplicate if custom role name matches
                    if (!chips.some(c => c.name.toLowerCase() === pretty.toLowerCase())) {
                        chips.push({ name: pretty, color: baseColor });
                    }
                }
                if (chips.length === 0) chips.push({ name: 'Member', color: '#8e9297' });
                chips.forEach(c => {
                    const chip = document.createElement('div');
                    chip.className = 'role-chip';
                    const dot = document.createElement('span');
                    dot.className = 'role-dot';
                    dot.style.background = c.color;
                    const label = document.createElement('span');
                    label.textContent = c.name;
                    chip.appendChild(dot);
                    chip.appendChild(label);
                    rolesEl.appendChild(chip);
                });
            } catch (e) {
                // Fallback single chip
                const chip = document.createElement('div');
                chip.className = 'role-chip';
                chip.innerHTML = '<span class="role-dot"></span><span>Member</span>';
                rolesEl.appendChild(chip);
            }

            modal.style.display = 'block';
        }

        function hideProfilePopover() {
            const pop = document.getElementById('profile-popover');
            pop.style.display = 'none';
            window.__popoverUserId = null;
        }

        function openFullProfileFromPopover() {
            const name = document.getElementById('popover-profile-username')?.textContent || '';
            const avatarStyle = document.getElementById('popover-profile-avatar')?.style?.backgroundImage || '';
            const avatar = avatarStyle && avatarStyle.startsWith('url(') ? avatarStyle.slice(4, -1).replace(/"/g, '') : null;
            if (window.__popoverUserId) openUserProfile(window.__popoverUserId, name, avatar);
            hideProfilePopover();
        }

        async function openProfilePopover(ev, userId, fallbackUsername, fallbackAvatar = null) {
            ev?.stopPropagation?.();
            window.__popoverUserId = userId;
            const pop = document.getElementById('profile-popover');
            const rect = ev.currentTarget.getBoundingClientRect();
            // Position to the right of the clicked element, clamp within viewport
            const margin = 8;
            const width = 360; // matches CSS width
            let top = rect.top;
            let left = rect.right + margin;
            if (left + width > window.innerWidth - margin) {
                // Place to the left if no space on right
                left = Math.max(margin, rect.left - width - margin);
            }
            // Clamp vertical position
            const maxTop = window.innerHeight - 20 - 260; // approx popover height
            top = Math.max(12, Math.min(top, maxTop));
            pop.style.top = `${top + window.scrollY}px`;
            pop.style.left = `${left + window.scrollX}px`;

            // Clear old state and set optimistic
            const nameEl = document.getElementById('popover-profile-username');
            const avatarEl = document.getElementById('popover-profile-avatar');
            const headerEl = document.getElementById('popover-profile-header');
            const bioEl = document.getElementById('popover-profile-bio');
            const bioWrapEl = document.getElementById('popover-bio-wrap');
            const rolesWrapEl = document.getElementById('popover-roles');
            const rolesSepEl = document.getElementById('popover-roles-sep');
            const roleListEl = document.getElementById('popover-role-list');
            const serversEl = document.getElementById('popover-profile-servers');
            const serverListEl = document.getElementById('popover-profile-server-list');
            if (nameEl) nameEl.textContent = fallbackUsername || '';
            if (avatarEl) {
                if (fallbackAvatar) {
                    avatarEl.style.backgroundImage = `url(${fallbackAvatar})`;
                    avatarEl.style.backgroundSize = 'cover';
                    avatarEl.style.backgroundPosition = 'center';
                    avatarEl.style.backgroundRepeat = 'no-repeat';
                    avatarEl.textContent = '';
                } else {
                    avatarEl.style.backgroundImage = '';
                    avatarEl.textContent = (fallbackUsername || '?').charAt(0).toUpperCase();
                }
            }
            if (headerEl) headerEl.style.backgroundImage = '';
            if (bioEl) { bioEl.textContent = ''; }
            if (bioWrapEl) bioWrapEl.style.display = 'none';
            if (rolesWrapEl) rolesWrapEl.style.display = 'none';
            if (rolesSepEl) rolesSepEl.style.display = 'none';
            if (roleListEl) roleListEl.innerHTML = '';
            if (serversEl) { serversEl.style.display = 'none'; }
            if (serverListEl) serverListEl.innerHTML = '';
            pop.style.display = 'block';

            // Before network: fill roles for the current server from caches
            try {
                if (currentServer && currentServer.id) {
                    if (!currentServerMembersMap || currentServerMembersMap.size === 0 || currentServerMembersCacheServerId !== parseFloat(currentServer.id)) {
                        await loadServerMembersCache(currentServer.id);
                    }
                    const member = currentServerMembersMap.get(parseInt(userId));
                    const rolesMap = serverRolesCache.get(parseFloat(currentServer.id)) || {};
                    const chips = [];
                    if (member?.roleId && rolesMap[member.roleId]) {
                        const r = rolesMap[member.roleId];
                        chips.push({ name: r.name || 'Role', color: r.color || '#5865f2' });
                    }
                    if (member?.role) {
                        const baseColor = member.role === 'owner' ? '#43b581' : member.role === 'admin' ? '#7289da' : '#8e9297';
                        const pretty = member.role.charAt(0).toUpperCase() + member.role.slice(1);
                        if (!chips.some(c => c.name.toLowerCase() === pretty.toLowerCase())) {
                            chips.push({ name: pretty, color: baseColor });
                        }
                    }
                    if (chips.length > 0 && rolesWrapEl && roleListEl) {
                        roleListEl.innerHTML = '';
                        chips.forEach(c => {
                            const chip = document.createElement('div');
                            chip.className = 'role-chip';
                            const dot = document.createElement('span');
                            dot.className = 'role-dot';
                            dot.style.background = c.color;
                            const label = document.createElement('span');
                            label.textContent = c.name;
                            chip.appendChild(dot);
                            chip.appendChild(label);
                            roleListEl.appendChild(chip);
                        });
                        rolesWrapEl.style.display = 'flex';
                        if (rolesSepEl) rolesSepEl.style.display = 'block';
                    }
                }
            } catch (e) { /* ignore roles errors */ }

            // Fetch full public profile (banner, bio, servers)
            try {
                const res = await fetch(`/api/users/${encodeURIComponent(userId)}/profile`, {
                    headers: { 'Authorization': `Bearer ${localStorage.getItem('token') || ''}` }
                });
                if (!res.ok) return;
                const profile = await res.json();
                if (nameEl) nameEl.textContent = profile.username || fallbackUsername || '';
                if (avatarEl) {
                    if (profile.avatar) {
                        avatarEl.style.backgroundImage = `url(${profile.avatar})`;
                        avatarEl.style.backgroundSize = 'cover';
                        avatarEl.style.backgroundPosition = 'center';
                        avatarEl.style.backgroundRepeat = 'no-repeat';
                        avatarEl.textContent = '';
                    } else {
                        avatarEl.style.backgroundImage = '';
                        avatarEl.textContent = (profile.username || fallbackUsername || '?').charAt(0).toUpperCase();
                    }
                }
                if (headerEl) {
                    if (profile.banner) {
                        headerEl.style.backgroundImage = `url(${profile.banner})`;
                        headerEl.style.backgroundSize = 'cover';
                        headerEl.style.backgroundPosition = 'center';
                        headerEl.style.backgroundRepeat = 'no-repeat';
                    } else {
                        headerEl.style.backgroundImage = '';
                    }
                }
                if (bioEl && bioWrapEl) {
                    bioEl.innerHTML = renderBio(profile.bio || '');
                    bioWrapEl.style.display = profile.bio ? 'block' : 'none';
                }
                if (serverListEl) {
                    serverListEl.innerHTML = '';
                    const servers = Array.isArray(profile.servers) ? profile.servers : [];
                    servers.forEach(sv => {
                        const chip = document.createElement('div');
                        chip.className = 'profile-server-chip';
                        const icon = document.createElement('div');
                        icon.className = 'profile-server-icon';
                        if (sv.icon) {
                            icon.style.backgroundImage = `url(${sv.icon})`;
                        } else {
                            icon.style.backgroundImage = '';
                            icon.textContent = (sv.name || '?').charAt(0).toUpperCase();
                        }
                        const label = document.createElement('span');
                        label.textContent = sv.name || 'Server';
                        chip.appendChild(icon);
                        chip.appendChild(label);
                        serverListEl.appendChild(chip);
                    });
                    if (serversEl) serversEl.style.display = servers.length ? 'block' : 'none';
                }
            } catch (e) {
                console.error('Failed to load profile for popover', e);
            }
        }

        // Click-away to close the profile popover
        document.addEventListener('click', (e) => {
            const pop = document.getElementById('profile-popover');
            if (!pop || pop.style.display !== 'block') return;
            const within = pop.contains(e.target);
            // ignore clicks that originate from member/admin items that open the popover
            const opener = e.target.closest?.('.member-item, .admin-chip');
            if (!within && !opener) hideProfilePopover();
        });
        // Escape key to close
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') hideProfilePopover();
        });

        async function checkChannelManagementPermission(serverId) {
            try {
                const response = await fetch(`/api/servers/${serverId}/members`, {
                    headers: {
                        'Authorization': `Bearer ${localStorage.getItem('token')}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    const currentUserMember = data.members.find(m => m.userId === currentUser.id);
                    
                    // Show channel management button only for owners and admins
                    const addChannelBtn = document.getElementById('add-channel-btn');
                    if (currentUserMember && (currentUserMember.role === 'owner' || currentUserMember.role === 'admin')) {
                        addChannelBtn.style.display = 'flex';
                    } else {
                        addChannelBtn.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Error checking channel management permission:', error);
                // Hide button on error
                document.getElementById('add-channel-btn').style.display = 'none';
            }
        }
    </script>
</body>
</html>